<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>AI Boxing Coach — FINAL DEPENDENCY FIX (MediaPipe)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose"></script> 
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
  
  <style>
    body { 
      margin:0; padding:0; 
      font-family:system-ui, Arial;
      background:#0a0a0a; color:#eee; 
      display:flex; flex-direction:column; 
      align-items:center; 
      overflow:hidden;
    }
    #wrap {
      position:relative;
      width:100vw; 
      max-width:450px;   
      height:75vh;       
      background:#000;
      border-radius:10px;
      overflow:hidden;
    }
    video, canvas { 
      position:absolute;
      top:0; left:0;
      width:100%; height:100%;
      object-fit:cover;
    }

    /* CRITICAL: Hidden canvas for pre-processing */
    #hiddenCanvas {
        display: none; 
    }

    #hud {
      position:absolute;
      top:0; left:0;
      width:100%;
      display:flex;
      flex-wrap:wrap;
      justify-content:space-between;
      background:rgba(0,0,0,0.35);
      padding:6px 10px;
      font-size:12px;
      box-sizing:border-box;
      z-index: 5;
    }
    .stat { 
      padding:2px 4px;
      color:#0ff; font-weight:600;
    }
    
    /* NEW DEBUG PANEL STYLE */
    #debug {
      width: 100%;
      padding-top: 5px;
      border-top: 1px solid rgba(255, 255, 255, 0.2);
      font-size: 10px;
    }
    #debug span {
        margin-right: 10px;
    }
    /* Style for the error message */
    #status.error {
        color: #ff6b6b; /* Bright red for errors */
        font-weight: bold;
    }

    #controls {
      margin-top:10px;
      display:flex; gap:6px;
      flex-wrap:wrap;
      justify-content:center;
    }
    button { 
      padding:8px 12px; border-radius:8px; 
      border:0; background:#007bff; 
      color:#fff; font-weight:600;
      cursor: pointer;
    }
    #feedback {
      margin-top:10px;
      font-size: 18px;
      font-weight: bold;
      color: #ffeb3b;
      text-align: center;
      min-height: 24px;
      opacity: 0;
      transition: opacity 0.2s;
    }
    .secondary {
      background: #444;
    }
    button:disabled {
      opacity: 0.5;
      cursor: default;
    }
  </style>
</head>
<body>
  <h3 style="margin:10px 0 5px 0">AI Boxing Coach — FINAL DEPENDENCY FIX</h3>

  <div id="wrap">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
    <canvas id="hiddenCanvas"></canvas>

    <div id="hud">
      <div class="row">
        <div><span class="stat">Jabs</span> <span id="jabs">0</span>  • <span class="stat">Crosses</span> <span id="crosses">0</span></div>
        <div><span class="stat">Hooks</span> <span id="hooks">0</span> • <span class="stat">Uppercut</span> <span id="uppercuts">0</span></div>
      </div>
      <div class="row">
        <div><small>Guard %</small> <span id="guardPercent">0%</span></div>
        <div><small>Chin exposed</small> <span id="chinPct">0%</span></div>
      </div>
      <div class="row">
        <div><small>Fastest (m/s)</small> <span id="fastest">0</span></div>
        <div><small>Power est.</small> <span id="power">0</span></div>
      </div>
      
      <div id="debug">
          <small>Status: <span id="status">idle</span></small>
          <br/>
          <span>Latency: <b id="latency">0ms</b></span>
          <span>Max Score: <b id="confidence">0.0</b></span>
          <span>Resolution: <b id="res">0x0</b></span>
      </div>
    </div>
    
  </div>

  <div id="controls">
    <button id="startBtn">Start</button>
    <button id="stopBtn" class="secondary" disabled>Stop</button>
    <button id="resetBtn" class="secondary">Reset</button>
    <button id="calBtn" class="secondary">Calibrate (Stand)</button>
  </div>

  <div id="feedback"></div>

<script>
(async ()=> {
  // Elements
  const video = document.getElementById('video');
  const overlayCanvas = document.getElementById('overlay');
  const overlayCtx = overlayCanvas.getContext('2d');
  const hiddenCanvas = document.getElementById('hiddenCanvas');
  const hiddenCtx = hiddenCanvas.getContext('2d');
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const resetBtn = document.getElementById('resetBtn');
  const calBtn = document.getElementById('calBtn');
  const statusEl = document.getElementById('status');
  const feedbackEl = document.getElementById('feedback');
  
  // New Debug Elements
  const latencyEl = document.getElementById('latency');
  const confidenceEl = document.getElementById('confidence');
  const resEl = document.getElementById('res');

  const jabsEl = document.getElementById('jabs');
  const crossesEl = document.getElementById('crosses');
  const hooksEl = document.getElementById('hooks');
  const uppercutsEl = document.getElementById('uppercuts');
  const guardPctEl = document.getElementById('guardPercent');
  const chinPctEl = document.getElementById('chinPct');
  const fastestEl = document.getElementById('fastest');
  const powerEl = document.getElementById('power');

  // State
  let detector = null;
  let running = false;
  let raf = null;
  let stream = null;
  let lastFeedbackAt = 0;
  
  let jabs=0, crosses=0, hooks=0, uppercuts=0;
  let frameCount = 0;
  let guardFrames = 0; 
  let chinExposedFrames = 0;
  let startTime = 0;

  let prevLeft = null, prevRight = null, prevNose = null;

  // thresholds (tweakable)
  const punchCooldown = 300; 
  const speedThreshold = 0.035; 
  const uppercutYThreshold = 0.02; 
  let guardDistThreshold = 0.18; 
  const rotationPowerFactor = 1.2; 
  const VISUAL_SCORE_THRESHOLD = 0.05; // Extremely low for max visibility attempt

  let lastLeftAt = 0, lastRightAt = 0;

  // speech and audio functions (omitted for brevity)
  const synth = window.speechSynthesis;
  function speak(s) {
    if (!synth) return;
    const ut = new SpeechSynthesisUtterance(s);
    ut.rate = 1.05; ut.pitch = 1;
    synth.speak(ut);
  }
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  function beep() {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine'; o.frequency.value = 1000;
    g.gain.value = 0.0001; o.connect(g); g.connect(audioCtx.destination);
    o.start();
    g.gain.exponentialRampToValueAtTime(0.2, audioCtx.currentTime + 0.01);
    g.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.12);
    o.stop(audioCtx.currentTime + 0.13);
  }
  function giveFeedback(text, speakIt=true) {
    const t = now();
    if (t - lastFeedbackAt < 1000) return;
    lastFeedbackAt = t;
    feedbackEl.textContent = text;
    feedbackEl.style.opacity = 1;
    setTimeout(()=> feedbackEl.style.opacity = 0, 1500);
    if (speakIt) speak(text);
    beep();
  }

  // start camera (selfie)
  async function startCamera() {
    const constraints = { 
      audio: false, 
      video: { 
        facingMode: "user", 
        // CRITICAL: Requesting lowest possible stable resolution for speed
        width: { ideal: 320 }, 
        height: { ideal: 240 } 
      } 
    };
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    
    return new Promise((resolve) => {
      video.onloadedmetadata = () => {
        video.play();
        
        // Set canvas sizes based on actual video dimensions
        video.width = video.videoWidth;
        video.height = video.videoHeight;
        overlayCanvas.width = video.videoWidth;
        overlayCanvas.height = video.videoHeight;
        hiddenCanvas.width = video.videoWidth;
        hiddenCanvas.height = video.videoHeight;
        
        // Update Resolution display element
        resEl.textContent = `${video.videoWidth}x${video.videoHeight}`;

        video.setAttribute("playsinline", "true");
        video.style.transform = "scaleX(-1)"; // CSS mirror for visual feedback
        resolve();
      };
    });
  }

  async function loadDetector() {
    statusEl.textContent = 'loading model (1/3: setting up MediaPipe)...';
    statusEl.classList.remove('error'); // Reset status style
    
    const model = poseDetection.SupportedModels.BlazePose;
    const detectorConfig = {
      runtime: 'mediapipe', 
      modelType: 'lite', // Using 'lite' for max speed/compatibility
      enableSmoothing: true,
      // CRITICAL: Specify the solutionPath since we are loading it explicitly
      solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/pose',
    };

    statusEl.textContent = 'loading model (2/3: waiting for dependencies to load)...';

    // Wait for the MediaPipe dependency to be fully loaded (just in case)
    await new Promise(resolve => {
        if (window.Pose) {
            resolve();
        } else {
            // Add a temporary listener for window.Pose to appear, but rely mostly on the script tag.
            // This is a safety check for slow CDNs.
            const checkInterval = setInterval(() => {
                if (window.Pose) {
                    clearInterval(checkInterval);
                    resolve();
                }
            }, 100);
            setTimeout(() => {
                if (!window.Pose) {
                    console.warn("MediaPipe Pose dependency slow to load or missing.");
                    resolve(); // Resolve anyway to proceed and catch the error below
                }
            }, 5000);
        }
    });

    statusEl.textContent = 'loading model (3/3: creating detector from MediaPipe Lite)...';
    try {
        detector = await poseDetection.createDetector(model, detectorConfig);
        statusEl.textContent = 'model loaded (BlazePose/MediaPipe Lite)';
    } catch (e) {
        // *** CRITICAL: Output the actual error message directly to the status element ***
        statusEl.textContent = `LOAD FAILED: ${e.name || 'Error'}: ${e.message || 'Unknown error details'}`;
        statusEl.classList.add('error'); // Apply error style (red color)
        
        console.error('Detector creation error:', e);
        // Also show in feedback element for better visibility
        feedbackEl.textContent = `CRASH: ${e.message || 'Unknown'}`;
        feedbackEl.style.opacity = 1;
    }
  }

  // utilities
  function dist(a,b) { return Math.hypot(a.x-b.x, a.y-b.y); }
  function now() { return performance.now(); }

  function analyzePose(kpMap) {
    const lw = kpMap['left_wrist'];
    const rw = kpMap['right_wrist'];
    const ls = kpMap['left_shoulder'];
    const rs = kpMap['right_shoulder'];
    const nose = kpMap['nose'];
    const lHip = kpMap['left_hip'];
    const rHip = kpMap['right_hip'];

    // Only proceed if critical points are present (shoulders/wrists/nose)
    if (!lw || !rw || !ls || !rs || !nose) return {};

    const normalizedKpMap = {
        'left_wrist': lw, 'right_wrist': rw,
        'left_shoulder': ls, 'right_shoulder': rs,
        'nose': nose,
        'left_hip': lHip, 'right_hip': rHip,
        'left_elbow': kpMap['left_elbow'], 'right_elbow': kpMap['right_elbow'],
        'left_knee': kpMap['left_knee'], 'right_knee': kpMap['right_knee'],
        'left_ankle': kpMap['left_ankle'], 'right_ankle': kpMap['right_ankle']
    };
    
    let leftVel = {x:0,y:0}, rightVel={x:0,y:0};
    if (prevLeft) { leftVel = { x: lw.x - prevLeft.x, y: lw.y - prevLeft.y }; }
    if (prevRight) { rightVel = { x: rw.x - prevRight.x, y: rw.y - prevRight.y }; }

    const leftToShoulder = dist(lw, ls);
    const rightToShoulder = dist(rw, rs);
    const leftToNose = dist(lw, nose);
    const rightToNose = dist(rw, nose);

    const leftGuard = (leftToShoulder < guardDistThreshold) || (leftToNose < guardDistThreshold);
    const rightGuard = (rightToShoulder < guardDistThreshold) || (rightToNose < guardDistThreshold);
    const bothGuard = leftGuard && rightGuard;
    
    const shoulderDistance = dist(ls, rs);
    const chinExposed = (leftToNose > shoulderDistance * 0.8) && (rightToNose > shoulderDistance * 0.8);
    
    let rotNorm = 0;
    if (lHip && rHip) {
      const shoulderAngle = Math.atan2(rs.y - ls.y, rs.x - ls.x);
      const hipAngle = Math.atan2(rHip.y - lHip.y, rHip.x - lHip.x);
      const rotation = Math.abs(shoulderAngle - hipAngle);
      rotNorm = Math.min(Math.PI, rotation) / Math.PI;
    }

    const leftSpeed = Math.hypot(leftVel.x, leftVel.y);
    const rightSpeed = Math.hypot(rightVel.x, rightVel.y);
    const leftPower = leftSpeed * (1 + rotNorm*rotationPowerFactor);
    const rightPower = rightSpeed * (1 + rotNorm*rotationPowerFactor);

    const events = [];
    const timestamp = now();

    // Punch detection logic
    if (prevLeft) {
      const prevDist = dist(prevLeft, ls);
      const currDist = leftToShoulder;
      const delta = currDist - prevDist;
      if (delta > speedThreshold && (timestamp - lastLeftAt) > punchCooldown) {
        if (Math.abs(leftVel.y) < 0.04 && Math.abs(leftVel.x) > 0.04) { hooks++; hooksEl.textContent = hooks; events.push({type:'hook'}); lastLeftAt = timestamp; }
        else if (leftVel.y < -uppercutYThreshold) { uppercuts++; uppercutsEl.textContent = uppercuts; events.push({type:'uppercut'}); lastLeftAt = timestamp; }
        else { jabs++; jabsEl.textContent = jabs; events.push({type:'jab'}); lastLeftAt = timestamp; }
      }
    }
    if (prevRight) {
      const prevDistR = dist(prevRight, rs);
      const currDistR = rightToShoulder;
      const deltaR = currDistR - prevDistR;
      if (deltaR > speedThreshold && (timestamp - lastRightAt) > punchCooldown) {
        if (Math.abs(rightVel.y) < 0.04 && Math.abs(rightVel.x) > 0.04) { hooks++; hooksEl.textContent = hooks; events.push({type:'hook'}); lastRightAt = timestamp; }
        else if (rightVel.y < -uppercutYThreshold) { uppercuts++; uppercutsEl.textContent = uppercuts; events.push({type:'uppercut'}); lastRightAt = timestamp; }
        else { crosses++; crossesEl.textContent = crosses; events.push({type:'cross'}); lastRightAt = timestamp; }
      }
    }

    if (chinExposed && Math.random() < 0.01) { giveFeedback("Hands up!"); }

    drawOverlay(normalizedKpMap, {bothGuard, chinExposed, leftSpeed, rightSpeed, leftPower, rightPower});

    prevLeft = {x: lw.x, y: lw.y};
    prevRight = {x: rw.x, y: rw.y};
    prevNose = {x: nose.x, y: nose.y};

    return {leftSpeed, rightSpeed, leftPower, rightPower, guard: bothGuard, chinExposed};
  }

  function drawOverlay(kpMap, meta) {
    const w = overlayCanvas.width, h = overlayCanvas.height;
    overlayCtx.clearRect(0,0,w,h);

    const keypointConnectionsMap = [
      ['left_shoulder', 'right_shoulder'], ['left_shoulder', 'left_elbow'],
      ['right_shoulder', 'right_elbow'], ['left_elbow', 'left_wrist'],
      ['right_elbow', 'right_wrist'], ['left_shoulder', 'left_hip'],
      ['right_shoulder', 'right_hip'], ['left_hip', 'right_hip'],
      ['left_hip', 'left_knee'], ['right_hip', 'right_knee'],
      ['left_knee', 'left_ankle'], ['right_knee', 'right_ankle'],
    ];

    overlayCtx.save();
    overlayCtx.strokeStyle = 'rgba(0,255,255,0.7)';
    overlayCtx.lineWidth = 2;
    
    // Draw connections (skeleton)
    for (const [p1Name, p2Name] of keypointConnectionsMap) {
      const p1 = kpMap[p1Name];
      const p2 = kpMap[p2Name];
      // Draw connection if both keypoints meet the extremely low score threshold
      if (p1 && p2 && p1.score > VISUAL_SCORE_THRESHOLD && p2.score > VISUAL_SCORE_THRESHOLD) {
        overlayCtx.beginPath();
        overlayCtx.moveTo(p1.x * w, p1.y * h);
        overlayCtx.lineTo(p2.x * w, p2.y * h);
        overlayCtx.stroke();
      }
    }
    
    // Draw keypoints (joints)
    overlayCtx.fillStyle = 'rgba(0,255,255,0.8)';
    for (const k of Object.values(kpMap)) {
      // Draw keypoint if it meets the extremely low score threshold
      if (k && k.score > VISUAL_SCORE_THRESHOLD) {
        overlayCtx.beginPath();
        overlayCtx.arc(k.x * w, k.y * h, 6, 0, Math.PI*2);
        overlayCtx.fill();
      }
    }
    overlayCtx.restore();

    // Guard/Chin visual feedback 
    overlayCtx.save();
    if (meta.chinExposed) {
      overlayCtx.strokeStyle = 'rgba(255,80,80,0.8)';
      overlayCtx.lineWidth = 5;
      overlayCtx.strokeRect(10,10,w-20,h-20);
    } else if (meta.bothGuard) {
      overlayCtx.strokeStyle = 'rgba(0,255,100,0.6)';
      overlayCtx.lineWidth = 5;
      overlayCtx.strokeRect(10,10,w-20,h-20);
    }
    overlayCtx.restore();
  }
  
  let lastTime = 0;

  async function runFrame() {
    if (!running) return;
    if (!detector) {
        statusEl.textContent = 'Detector not initialized. Press Start.';
        statusEl.classList.add('error');
        return;
    }
    
    const vw = video.videoWidth;
    const vh = video.videoHeight;
    const start = now();
    
    try {
      // 1. Draw the current video frame onto the HIDDEN canvas (Flips for correction)
      hiddenCtx.save();
      hiddenCtx.scale(-1, 1);
      hiddenCtx.drawImage(video, -vw, 0, vw, vh);
      hiddenCtx.restore();

      // 2. Pass the HIDDEN CANVAS data to the detector
      const poses = await detector.estimatePoses(hiddenCanvas, { flipHorizontal: false });
      
      const end = now();
      const latency = (end - start).toFixed(0);
      latencyEl.textContent = `${latency}ms`;
      
      // Calculate FPS for easier reading (1000 / latency)
      if (latency > 0) {
          statusEl.textContent = `running (FPS: ${(1000 / latency).toFixed(1)} | Poses: ${poses.length})`;
      } else {
          statusEl.textContent = `running (Poses: ${poses.length})`;
      }
      statusEl.classList.remove('error'); // Ensure color is normal if running

      let maxScore = 0.0;

      if (poses && poses.length > 0) {
        const primaryPose = poses[0];
        // Calculate Max Score for the pose
        maxScore = primaryPose.score.toFixed(2);
        
        const pts = primaryPose.keypoints.reduce((map, k) => {
            map[k.name] = k;
            return map;
        }, {});
        
        const kpMap = {};
        if (vw > 0 && vh > 0) {
            for (const k of Object.values(pts)) {
              kpMap[k.name] = { x: k.x / vw, y: k.y / vh, score: k.score };
            }
            const res = analyzePose(kpMap);
            
            // update UI numbers
            frameCount++;
            guardFrames += res.guard ? 1 : 0;
            chinExposedFrames += res.chinExposed ? 1 : 0;
            fastestEl.textContent = Math.max(Number(fastestEl.textContent)||0, (res.leftSpeed||0).toFixed(3), (res.rightSpeed||0).toFixed(3));
            powerEl.textContent = Math.max(Number(powerEl.textContent)||0, (res.leftPower||0).toFixed(3), (res.rightPower||0).toFixed(3));
            guardPctEl.textContent = Math.round((guardFrames/frameCount||0)*100) + '%';
            chinPctEl.textContent = Math.round((chinExposedFrames/frameCount||0)*100) + '%';
        }
      } else {
        // Clear canvas if no person is detected
        overlayCtx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);
      }
      
      // Update confidence display after processing
      confidenceEl.textContent = maxScore;
      
    } catch (err) {
      console.error('estimation error', err);
      // Display error prominently in the status field
      statusEl.textContent = `CRASH: ${err.message || 'Unknown Error'}`;
      statusEl.classList.add('error');
      feedbackEl.textContent = `CRASH: ${err.message || 'Unknown Error'}`;
      feedbackEl.style.opacity = 1;
      running = false; // Stop the loop on error
    }
    
    // Only request the next frame if still running
    if (running) {
        raf = requestAnimationFrame(runFrame);
    }
  }

  // controls (start/stop/reset/calibrate)
  startBtn.onclick = async () => {
    startBtn.disabled = true;
    stopBtn.disabled = false;
    resetBtn.disabled = false;
    statusEl.textContent = 'starting camera (asking for 320x240)...';
    statusEl.classList.remove('error');
    try {
      await startCamera();
    } catch (e) {
      alert('Camera error. Ensure camera permissions are granted. Error: '+ (e.message || e));
      startBtn.disabled = false;
      stopBtn.disabled = true;
      statusEl.textContent = 'Camera failed to start.';
      statusEl.classList.add('error');
      return;
    }
    if (!detector) await loadDetector();
    if (statusEl.classList.contains('error')) { // Check if loading failed
        startBtn.disabled = false;
        stopBtn.disabled = true;
        return; 
    }
    running = true;
    startTime = Date.now();
    video.play();
    runFrame();
    if (audioCtx.state === 'suspended') audioCtx.resume();
  };

  stopBtn.onclick = () => {
    running = false;
    startBtn.disabled = false;
    stopBtn.disabled = true;
    statusEl.textContent = 'stopped';
    statusEl.classList.remove('error');
    if (raf) cancelAnimationFrame(raf);
    if (stream) {
      const tracks = stream.getTracks();
      tracks.forEach(t => t.stop());
      stream = null;
    }
  };

  resetBtn.onclick = () => {
    jabs = crosses = hooks = uppercuts = 0;
    jabsEl.textContent = 0; crossesEl.textContent=0; hooksEl.textContent=0; uppercutsEl.textContent=0;
    frameCount = guardFrames = chinExposedFrames = 0;
    prevLeft = prevRight = prevNose = null;
    feedbackEl.textContent = '';
    fastestEl.textContent = '0';
    powerEl.textContent = '0';
    guardPctEl.textContent = '0%';
    chinPctEl.textContent = '0%';
  };

  calBtn.onclick = () => {
    // Calibration logic relies on wrist/nose distance
    giveFeedback("Calibrating... stand in guard");
    setTimeout(()=> {
      if (prevLeft && prevRight && prevNose) {
        const avgLeft = dist(prevLeft, prevNose);
        const avgRight = dist(prevRight, prevNose);
        const avg = (avgLeft + avgRight) / 2;
        // set guard threshold to avg * 1.5 (tolerant)
        const newGuard = Math.max(0.10, Math.min(0.30, avg * 1.5));
        guardDistThreshold = newGuard; 
        giveFeedback("Calibration set!");
      } else {
        giveFeedback("Could not see wrists/nose");
      }
    }, 1000);
  };

  // init ready
  statusEl.textContent = 'ready';
})();
</script>
</body>
</html>
