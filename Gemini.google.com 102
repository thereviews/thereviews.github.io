<!doctype html>
<html>
<head>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-converter"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
  
  <meta charset="utf-8" />
  <title>AI Boxing Coach â€” Fixed</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  
  <style>
    body { 
      margin:0; padding:0; 
      font-family:system-ui, Arial;
      background:#0a0a0a; color:#eee; 
      display:flex; flex-direction:column; 
      align-items:center; 
      overflow:hidden;
    }
    #wrap {
      position:relative;
      width:100vw; 
      max-width:450px;
      height:75vh;
      background:#000;
      border-radius:10px;
      overflow:hidden;
      margin-top: 10px;
    }
    video, canvas { 
      position:absolute;
      top:0; left:0;
      width:100%; height:100%;
      object-fit:cover; /* Ensure full screen fill */
    }

    #hud {
      position:absolute;
      top:0; left:0;
      width:100%;
      display:flex;
      flex-wrap:wrap;
      justify-content:space-between;
      background:rgba(0,0,0,0.4);
      padding:6px 10px;
      font-size:12px;
      box-sizing:border-box;
      pointer-events: none; /* Let clicks pass through */
    }
    .stat { color:#0ff; font-weight:600; margin-right: 4px;}
    .row { width: 100%; display: flex; justify-content: space-between; margin-bottom: 2px;}

    #controls {
      margin-top:10px;
      display:flex; gap:8px;
      flex-wrap:wrap;
      justify-content:center;
      width: 100%;
      max-width: 450px;
    }
    button { 
      padding:10px 16px; border-radius:8px; 
      border:0; background:#007bff; 
      color:#fff; font-weight:600;
      font-size: 14px;
      touch-action: manipulation;
    }
    .secondary { background: #444; }
    button:disabled { opacity: 0.5; }
    
    #feedback {
      position: absolute;
      bottom: 20%;
      width: 100%;
      text-align: center;
      font-size: 24px;
      font-weight: 800;
      color: #ffeb3b;
      text-shadow: 0px 2px 4px #000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 5;
    }
    
    #summary {
      display:none;
      position:absolute;
      top:50%; left:50%;
      transform:translate(-50%, -50%);
      background:rgba(20,20,20,0.95);
      border:1px solid #444;
      padding:20px;
      border-radius:8px;
      z-index:10;
      text-align:center;
      width: 80%;
    }
  </style>
</head>
<body>

  <div id="wrap">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
    <div id="feedback"></div>

    <div id="hud">
      <div class="row">
        <div><span class="stat">Jabs</span><span id="jabs">0</span></div>
        <div><span class="stat">Cross</span><span id="crosses">0</span></div>
        <div><span class="stat">Hook</span><span id="hooks">0</span></div>
        <div><span class="stat">Upper</span><span id="uppercuts">0</span></div>
      </div>
      <div class="row" style="margin-top:4px; border-top:1px solid #444; padding-top:4px;">
        <div><small>Guard:</small> <span id="guardPercent">0%</span></div>
        <div><small>Exposed:</small> <span id="chinPct">0%</span></div>
      </div>
      <div class="row">
        <div><small>Max Spd:</small> <span id="fastest">0</span></div>
        <div><small>Pwr:</small> <span id="power">0</span></div>
      </div>
      <div id="debug" style="width:100%; text-align:center; margin-top:5px; color:#aaa;">
        <small id="status">Status: Ready</small>
      </div>
    </div>
    
    <div id="summary">
      <h3 style="margin-top:0; color:#fff;">Session Summary</h3>
      <div id="sumContent" style="margin-bottom:15px; text-align:left; color:#ccc; line-height:1.6;"></div>
      <button onclick="document.getElementById('summary').style.display='none'" style="width:100%">Close</button>
    </div>
  </div>

  <div id="controls">
    <button id="startBtn">START CAMERA</button>
    <button id="calBtn" class="secondary">Calibrate</button>
    <button id="stopBtn" class="secondary" disabled>Stop</button>
    <button id="resetBtn" class="secondary">Reset</button>
    <button id="summaryBtn" class="secondary">Stats</button>
  </div>

<script>
(async ()=> {
  const video = document.getElementById('video');
  const canvas = document.getElementById('overlay');
  const ctx = canvas.getContext('2d');
  const statusEl = document.getElementById('status');
  const feedbackEl = document.getElementById('feedback');
  
  // Stats Elements
  const els = {
    jabs: document.getElementById('jabs'),
    crosses: document.getElementById('crosses'),
    hooks: document.getElementById('hooks'),
    uppercuts: document.getElementById('uppercuts'),
    guard: document.getElementById('guardPercent'),
    chin: document.getElementById('chinPct'),
    fastest: document.getElementById('fastest'),
    power: document.getElementById('power')
  };

  let detector = null;
  let running = false;
  let raf = null;
  let stream = null;

  // Logic State
  let stats = { jabs:0, crosses:0, hooks:0, uppercuts:0 };
  let frameCount = 0, guardFrames = 0, chinExposedFrames = 0;
  let startTime = 0;
  
  // Physics tracking
  let prevLeft=null, prevRight=null, prevNose=null;
  let lastPunchTime = 0;
  let guardDistThreshold = 0.18; // Normalized distance

  // Audio
  const synth = window.speechSynthesis;
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  function speak(text) {
    if (!synth || synth.speaking) return;
    const ut = new SpeechSynthesisUtterance(text);
    ut.rate = 1.2; 
    synth.speak(ut);
  }

  function beep() {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.connect(g); g.connect(audioCtx.destination);
    o.frequency.value = 800;
    g.gain.value = 0.1;
    o.start();
    g.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.1);
    o.stop(audioCtx.currentTime + 0.1);
  }

  // --- 1. CORE FIX: ROBUST CAMERA SETUP ---
  async function startCamera() {
    statusEl.textContent = 'Requesting camera...';
    
    // Request ideal mobile resolution
    const stream = await navigator.mediaDevices.getUserMedia({
      audio: false,
      video: {
        facingMode: 'user',
        width: { ideal: 640 },
        height: { ideal: 480 }
      }
    });
    
    video.srcObject = stream;
    
    // Wait for data to actually arrive
    return new Promise((resolve) => {
      video.onloadeddata = () => {
        video.play();
        // CRITICAL: Set explicit width/height on the video element
        // TensorFlow.js needs these to match the stream exactly
        const vw = video.videoWidth;
        const vh = video.videoHeight;
        video.width = vw;
        video.height = vh;
        canvas.width = vw;
        canvas.height = vh;
        
        statusEl.textContent = `Camera active (${vw}x${vh})`;
        resolve();
      };
    });
  }

  async function loadModel() {
    statusEl.textContent = 'Loading AI Model...';
    await tf.ready();
    const model = poseDetection.SupportedModels.MoveNet;
    detector = await poseDetection.createDetector(model, {
      modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING
    });
    statusEl.textContent = 'Model Ready!';
  }

  // --- 2. LOGIC LOOP ---
  async function runFrame() {
    if (!running) return;

    // Safety check for video dimensions
    if (video.videoWidth === 0 || video.videoHeight === 0) {
      raf = requestAnimationFrame(runFrame);
      return;
    }

    try {
      const poses = await detector.estimatePoses(video, { flipHorizontal: true });
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (poses && poses.length > 0) {
        const p = poses[0];
        // Only trust high confidence poses
        if (p.score > 0.25) {
            statusEl.textContent = "Status: Running (Tracking)";
            processPose(p.keypoints);
            drawPose(p.keypoints);
        } else {
            statusEl.textContent = "Status: Running (Low Confidence - Check Light)";
        }
      } else {
        statusEl.textContent = "Status: Running (NO POSE DETECTED)";
      }
    } catch (e) {
      console.error(e);
      statusEl.textContent = "Error: " + e.message;
    }

    raf = requestAnimationFrame(runFrame);
  }

  function processPose(kps) {
    // Map keypoints to a simple object
    const kp = {};
    const w = canvas.width;
    const h = canvas.height;

    // Normalize: Convert pixels to 0..1 range
    kps.forEach(k => {
      kp[k.name] = { x: k.x / w, y: k.y / h, score: k.score };
    });

    const lw = kp['left_wrist'];
    const rw = kp['right_wrist'];
    const nose = kp['nose'];
    const ls = kp['left_shoulder'];
    
    if (!lw || !rw || !nose || !ls) return;

    // --- LOGIC ---
    const now = Date.now();
    
    // 1. Guard Detection
    const lDist = Math.hypot(lw.x - nose.x, lw.y - nose.y);
    const rDist = Math.hypot(rw.x - nose.x, rw.y - nose.y);
    const inGuard = lDist < guardDistThreshold && rDist < guardDistThreshold;
    const exposed = lDist > 0.25 && rDist > 0.25;

    frameCount++;
    if (inGuard) guardFrames++;
    if (exposed) chinExposedFrames++;

    // 2. Punch Detection (Velocity based)
    if (prevLeft && prevRight) {
        // Calculate velocity (delta)
        const lv = Math.hypot(lw.x - prevLeft.x, lw.y - prevLeft.y);
        const rv = Math.hypot(rw.x - prevRight.x, rw.y - prevRight.y);
        
        // Thresholds
        const speedThresh = 0.04; 
        
        // Left Punch
        if (lv > speedThresh && (now - lastPunchTime > 350)) {
            // Check direction (extension away from shoulder)
            const distShoulder = Math.hypot(lw.x - ls.x, lw.y - ls.y);
            const prevDistShoulder = Math.hypot(prevLeft.x - ls.x, prevLeft.y - ls.y);
            
            if (distShoulder > prevDistShoulder + 0.02) {
                if (lw.y < nose.y - 0.05) {
                    stats.uppercuts++;
                    showFeedback("LEFT UPPERCUT");
                } else if (Math.abs(lw.x - prevLeft.x) > Math.abs(lw.y - prevLeft.y) * 2) {
                    stats.hooks++;
                    showFeedback("LEFT HOOK");
                } else {
                    stats.jabs++;
                    showFeedback("JAB");
                }
                lastPunchTime = now;
                updateStats();
                beep();
            }
        }
        
        // Right Punch
        if (rv > speedThresh && (now - lastPunchTime > 350)) {
             const distShoulder = Math.hypot(rw.x - ls.x, rw.y - ls.y); // Approx shoulder
             if (distShoulder > 0.1) { // Simple check
                if (rw.y < nose.y - 0.05) {
                    stats.uppercuts++;
                    showFeedback("RIGHT UPPERCUT");
                } else if (Math.abs(rw.x - prevRight.x) > Math.abs(rw.y - prevRight.y) * 2) {
                    stats.hooks++;
                    showFeedback("RIGHT HOOK");
                } else {
                    stats.crosses++;
                    showFeedback("CROSS");
                }
                lastPunchTime = now;
                updateStats();
                beep();
             }
        }
        
        // Update max speed UI
        const currMax = Math.max(lv, rv).toFixed(3);
        if (currMax > parseFloat(els.fastest.innerText)) {
            els.fastest.innerText = currMax;
        }
    }

    // Save prev
    prevLeft = { x: lw.x, y: lw.y };
    prevRight = { x: rw.x, y: rw.y };
    prevNose = { x: nose.x, y: nose.y };
    
    // UI Updates (throttled slightly by frame rate)
    els.guard.innerText = Math.round((guardFrames/frameCount)*100) + "%";
    els.chin.innerText = Math.round((chinExposedFrames/frameCount)*100) + "%";
  }

  function showFeedback(text) {
    feedbackEl.innerText = text;
    feedbackEl.style.opacity = 1;
    setTimeout(() => feedbackEl.style.opacity = 0, 800);
  }

  function updateStats() {
    els.jabs.innerText = stats.jabs;
    els.crosses.innerText = stats.crosses;
    els.hooks.innerText = stats.hooks;
    els.uppercuts.innerText = stats.uppercuts;
  }

  function drawPose(kps) {
    const w = canvas.width;
    const h = canvas.height;
    
    ctx.save();
    ctx.strokeStyle = '#00ffcc';
    ctx.lineWidth = 4;
    ctx.fillStyle = '#00ffcc';

    // Connections (Skeleton)
    const pairs = [
        ['left_shoulder','right_shoulder'],
        ['left_shoulder','left_elbow'],['left_elbow','left_wrist'],
        ['right_shoulder','right_elbow'],['right_elbow','right_wrist'],
        ['left_shoulder','left_hip'],['right_shoulder','right_hip']
    ];
    
    // Helper to find point
    const get = (n) => kps.find(k => k.name === n);

    pairs.forEach(pair => {
        const p1 = get(pair[0]);
        const p2 = get(pair[1]);
        if(p1 && p2 && p1.score>0.3 && p2.score>0.3) {
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }
    });

    // Draw Dots
    kps.forEach(k => {
        if(k.score > 0.3) {
            ctx.beginPath();
            ctx.arc(k.x, k.y, 6, 0, Math.PI*2);
            ctx.fill();
        }
    });
    ctx.restore();
  }

  // --- CONTROLS ---
  document.getElementById('startBtn').onclick = async () => {
    document.getElementById('startBtn').disabled = true;
    try {
        await startCamera();
        await loadModel();
        running = true;
        statusEl.textContent = "Status: Running";
        document.getElementById('stopBtn').disabled = false;
        runFrame();
    } catch(e) {
        alert("Startup Error: " + e.message);
        document.getElementById('startBtn').disabled = false;
    }
  };

  document.getElementById('stopBtn').onclick = () => {
    running = false;
    if(raf) cancelAnimationFrame(raf);
    document.getElementById('startBtn').disabled = false;
    document.getElementById('stopBtn').disabled = true;
    statusEl.textContent = "Status: Stopped";
  };
  
  document.getElementById('resetBtn').onclick = () => {
    stats = { jabs:0, crosses:0, hooks:0, uppercuts:0 };
    frameCount = guardFrames = chinExposedFrames = 0;
    updateStats();
    els.guard.innerText = "0%";
    els.chin.innerText = "0%";
    els.fastest.innerText = "0";
  };
  
  document.getElementById('calBtn').onclick = () => {
    showFeedback("CALIBRATING...");
    setTimeout(() => {
       if(prevLeft && prevNose) {
           const d = Math.hypot(prevLeft.x - prevNose.x, prevLeft.y - prevNose.y);
           guardDistThreshold = d * 1.3;
           showFeedback("DONE!");
       } else {
           showFeedback("NO POSE!");
       }
    }, 1000);
  };

  document.getElementById('summaryBtn').onclick = () => {
     document.getElementById('summary').style.display = 'block';
     document.getElementById('sumContent').innerHTML = `
        Total Punches: ${stats.jabs + stats.crosses + stats.hooks + stats.uppercuts}<br>
        Avg Guard: ${els.guard.innerText}
     `;
  };

})();
</script>
</body>
</html>
