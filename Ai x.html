<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>AI Boxing Coach â€” Defense & Sparring Modes</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose"></script> 
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
  
  <style>
    body { 
      margin:0; padding:0; 
      font-family:system-ui, Arial;
      background:#0a0a0a; color:#eee; 
      display:flex; flex-direction:column; 
      align-items:center; 
      overflow-x: hidden;
      overflow-y: auto; 
    }
    #wrap {
      position:relative;
      width:100vw; 
      max-width:450px;   
      max-height:60vh; 
      height: 500px; 
      background:#000;
      border-radius:10px;
      overflow:hidden;
    }
    video, canvas { 
      position:absolute;
      top:0; left:0;
      width:100%; height:100%;
      object-fit:cover;
    }
    #hiddenCanvas {
        display: none; 
    }
    #hud {
      position:absolute;
      top:0; left:0;
      width:100%;
      display:flex;
      flex-wrap:wrap;
      justify-content:space-between;
      background:rgba(0,0,0,0.35);
      padding:6px 10px;
      font-size:12px;
      box-sizing:border-box;
      z-index: 5;
    }
    .stat { 
      padding:2px 4px;
      color:#0ff; font-weight:600;
    }
    
    /* PUNCH COUNT STYLES */
    #punchCounts {
        display: flex;
        gap: 15px;
        flex-basis: 100%;
        margin-top: 5px;
        padding-top: 5px;
        border-top: 1px solid rgba(255, 255, 255, 0.2);
        justify-content: space-around; 
    }
    #punchCounts > div {
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    #punchCounts .punch-label {
        font-size: 10px;
        color: #bbb;
    }
    #punchCounts .punch-count {
        font-size: 14px;
        font-weight: bold;
        color: #fff;
    }
    
    /* COMMAND PANEL */
    #drillCommand {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 15px 25px;
        background: rgba(255, 255, 255, 0.95);
        color: #000;
        font-size: 18px;
        font-weight: bold;
        border-radius: 12px;
        z-index: 10;
        min-width: 200px;
        text-align: center;
        opacity: 0;
        transition: opacity 0.3s, background 0.3s;
        box-shadow: 0 4px 15px rgba(0,0,0,0.4);
    }
    
    /* ATTACK ANIMATION */
    #liveTestAttack {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 0;
        height: 0;
        background: white;
        transform: translate(-50%, -50%);
        border-radius: 5px;
        z-index: 10;
        opacity: 0;
        box-shadow: 0 0 15px rgba(255, 255, 255, 0.7);
    }
    .attack-from-left {
        left: 0;
        transform: translate(0, -50%);
        border-radius: 5px 50% 50% 5px; 
    }
    .attack-from-right {
        left: 100%;
        transform: translate(-100%, -50%);
        border-radius: 50% 5px 5px 50%;
    }

    /* END OF LIVE TEST STATE COLORS */
    .hit { background: red !important; }
    .slipped, .blocked { background: #00ff7f !important; }

    #debug {
      width: 100%;
      padding-top: 5px;
      margin-top: 5px;
      border-top: 1px solid rgba(255, 255, 255, 0.2);
      font-size: 10px;
    }
    #debug span {
        margin-right: 10px;
    }
    
    /* NEW PUNCH DEBUG SECTION */
    #punchDebug {
        margin-top: 5px;
        padding-top: 5px;
        border-top: 1px dashed rgba(255, 255, 255, 0.1);
        font-size: 10px;
    }
    #punchDebug b {
        color: #ffeb3b;
    }

    #controls {
      margin-top:10px;
      display:flex; gap:8px;
      flex-wrap:wrap;
      justify-content:center;
      max-width: 450px;
      padding: 0 10px;
    }
    button, select { 
      padding:10px 15px; border-radius:10px; 
      border:none; 
      font-weight:700;
      cursor: pointer;
      box-shadow: 0 4px #00000033;
      transition: all 0.1s ease-out;
    }
    button:active {
      transform: translateY(2px);
      box-shadow: 0 2px #00000033;
    }
    
    #startBtn { background: #007bff; color:#fff; }
    #stopBtn, #resetBtn { background: #444; color:#fff; }
    #startDefenseBtn { background: #00b0ff; color:#000; }
    #startSparringBtn, #sparringSelector { background: #ff7043; color:#000; }

    button:disabled, select:disabled {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
    }
    
    #feedback {
      margin-top:10px;
      font-size: 18px;
      font-weight: bold;
      text-align: center;
      min-height: 24px;
      opacity: 0;
      transition: opacity 0.2s;
    }

    /* ERROR LOG STYLES */
    #errorLog {
        width: 100%;
        max-width: 450px;
        margin-top: 10px; 
        margin-bottom: 20px;
        background: #1e1e1e;
        border: 1px solid #ff4444;
        padding: 10px;
        font-size: 10px;
        color: #ffaaaa;
        max-height: 80px; 
        overflow-y: scroll;
        box-sizing: border-box;
    }
    #errorLog h4 {
        margin: 0 0 5px 0;
        color: #ff4444;
    }
    
    #pendingStatus {
        min-height: 20px;
        text-align: center;
        font-size: 14px;
        color: #ffeb3b;
        margin-top: 5px;
    }
  </style>
</head>
<body>
  <h3 style="margin:10px 0 0 0">AI Boxing Coach ðŸ¥Š</h3>
  <div id="pendingStatus"></div> 
  
  <div id="wrap">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
    <canvas id="hiddenCanvas"></canvas>
    <div id="liveTestAttack"></div>

    <div id="hud">
      <div class="row">
        <div><span class="stat">PUNCH TOTAL:</span> <span id="punchesTotal">0</span></div>
      </div>
      
      <div id="punchCounts">
        <div>
            <span class="punch-label">JAB</span>
            <span class="punch-count" id="jabsCount">0</span>
        </div>
        <div>
            <span class="punch-label">CROSS</span>
            <span class="punch-count" id="crossesCount">0</span>
        </div>
        <div>
            <span class="punch-label">HOOK</span>
            <span class="punch-count" id="hooksCount">0</span>
        </div>
        <div>
            <span class="punch-label">UPPERCUT</span>
            <span class="punch-count" id="uppercutsCount">0</span>
        </div>
      </div>
      
      <div id="debug">
          <small>Status: <span id="status">idle</span></small>
          <br/>
          <span>Latency: <b id="latency">0ms</b></span>
          <span>Max Score: <b id="confidence">0.0</b></span> 
          <span>Mode: <b id="modeStatus">IDLE</b></span>
          
          <div id="punchDebug">
              Punch Status: <b id="punchStatus">Inactive</b><br/>
              Extension: <b id="extRatio">0.0</b> | Angle: <b id="armAngle">0Â°</b> | Center: <b id="centerCheck">No</b>
          </div>
      </div>
    </div>
    
    <div id="drillCommand"></div>
    
  </div>

  <div id="controls">
    <button id="startBtn">1. Start Camera</button>
    <button id="stopBtn" disabled>Stop</button>
    <button id="resetBtn">Reset Counts</button>
    
    <hr style="width:100%; border:0; margin:5px 0;">
    
    <button id="startDefenseBtn" disabled>2. Defense & Counter Drill</sutton>
    
    <hr style="width:100%; border:0; margin:5px 0;">
    
    <select id="sparringSelector" disabled>
        <option value="beginner">Beginner</option>
        <option value="moderate">Moderate</option>
        <option value="advanced">Advanced</option>
    </select>
    <button id="startSparringBtn" disabled>3. Start Sparring Mode</button>
  </div>

  <div id="feedback"></div>
  
  <div id="errorLog">
      <h4>JavaScript Error Log (for Debugging)</h4>
      <pre id="errorLogContent">No errors logged.</pre>
  </div>

<script>
(async ()=> {
  // Elements
  const video = document.getElementById('video');
  const overlayCanvas = document.getElementById('overlay');
  const overlayCtx = overlayCanvas.getContext('2d');
  const hiddenCanvas = document.getElementById('hiddenCanvas');
  const hiddenCtx = hiddenCanvas.getContext('2d');
  
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const resetBtn = document.getElementById('resetBtn');
  const startDefenseBtn = document.getElementById('startDefenseBtn'); // Renamed
  const startSparringBtn = document.getElementById('startSparringBtn'); // New
  const sparringSelector = document.getElementById('sparringSelector'); // New
  
  const statusEl = document.getElementById('status');
  const feedbackEl = document.getElementById('feedback');
  const drillCommandEl = document.getElementById('drillCommand'); 
  const liveTestAttackEl = document.getElementById('liveTestAttack');
  const errorLogContentEl = document.getElementById('errorLogContent');
  const pendingStatusEl = document.getElementById('pendingStatus'); 

  // HUD elements
  const latencyEl = document.getElementById('latency');
  const confidenceEl = document.getElementById('confidence');
  const modeStatusEl = document.getElementById('modeStatus');
  const punchesTotalEl = document.getElementById('punchesTotal');
  const jabsCountEl = document.getElementById('jabsCount');
  const crossesCountEl = document.getElementById('crossesCount');
  const hooksCountEl = document.getElementById('hooksCount');
  const uppercutsCountEl = document.getElementById('uppercutsCount'); 
  
  // NEW DEBUG ELEMENTS
  const punchStatusEl = document.getElementById('punchStatus');
  const extRatioEl = document.getElementById('extRatio');
  const armAngleEl = document.getElementById('armAngle');
  const centerCheckEl = document.getElementById('centerCheck');


  // State
  let detector = null;
  let running = false;
  let raf = null;
  let stream = null;
  
  // Punch counters
  let jabCount = 0; 
  let crossCount = 0;
  let hookCount = 0; 
  let uppercutCount = 0; 

  // Mode State
  const MODES = { IDLE: 'IDLE', DEFENSE_DRILL: 'DEFENSE_DRILL', SPARRING: 'SPARRING', PENDING: 'PENDING' };
  let currentMode = MODES.IDLE;
  let pendingMode = null; 
  let confidenceOK = false;
  const MIN_CONFIDENCE_THRESHOLD = 0.70; 
  const MIN_HIP_CONFIDENCE = 0.65; // Minimum hip confidence required for detection (Anti-cramping)

  // Defense/Attempt State
  let attempts = 0;
  const MAX_ATTEMPTS = 10;
  let drillScores = []; 
  
  // Drill/Sparring State
  let testResults = []; 
  let attackWindowActive = false;
  let attackHit = false;
  let attackTimeout = null;
  let requiredDefense = null;
  let currentSparringDifficulty = 'beginner';
  
  // Attack timings based on difficulty
  const DIFFICULTY_SETTINGS = {
      'beginner': { attackTime: 1200, waitTime: 3000, complexity: 1 }, 
      'moderate': { attackTime: 800, waitTime: 1800, complexity: 2 },
      'advanced': { attackTime: 500, waitTime: 1000, complexity: 3 },
  };

  // Previous keypoints for velocity/detection 
  let prevLeft = null, prevRight = null, prevNose = null, prevLHip = null, prevRHip = null;
  
  // Punch detection thresholds (Tweaked for better detection)
  const punchCooldown = 300; 
  const minExtensionRatio = 0.60; // TWEAKED: Slightly lower for easier detection
  const CENTER_LINE_X_BUFFER = 0.05; 
  const STRAIGHT_PUNCH_MAX_BEND_DEG = 25; // TWEAKED: Increased tolerance for straight punches
  const HOOK_PUNCH_MIN_BEND_DEG = 70; 
  const HOOK_PUNCH_MAX_BEND_DEG = 120; 
  const UPPERCUT_MIN_Y_VELOCITY = 0.005; 

  let lastLeftAt = 0, lastRightAt = 0;
  
  // Defense and Attack List (Expanded)
  const DEFENSE_ACTIONS = {
      1: ["slip_left", "slip_right"], // Basic slips
      2: ["slip_left", "slip_right", "block_left", "block_right"], // Slips + Blocks
      3: ["slip_left", "block_left", "slip_right", "block_right"], // Combinations of above for Sparring Mode planning
  };
  const ATTACK_TYPES = {
      1: [{type: 'JAB', side: 'left', defense: 'slip_left'}, {type: 'CROSS', side: 'right', defense: 'slip_right'}], // Straight punches only
      2: [...this[1], {type: 'LEFT HOOK', side: 'left', defense: 'block_right'}, {type: 'RIGHT HOOK', side: 'right', defense: 'block_left'}], // Straights + Hooks
      3: [...this[2], {type: 'JAB, CROSS', side: 'left', defense: 'slip_left'}] // Combo (Defense is for the first punch) - Future work
  };

  // --- Debugging / Error Logging ---
  function logError(message, source) {
      const now = new Date().toLocaleTimeString();
      const entry = `[${now}] [${source}] ${message}`;
      
      console.error(entry);
      errorLogContentEl.textContent = entry + '\n' + errorLogContentEl.textContent;
      if (errorLogContentEl.textContent.length > 2000) {
          errorLogContentEl.textContent = errorLogContentEl.textContent.substring(0, 1500) + '\n... [TRUNCATED]';
      }
      if (errorLogContentEl.textContent.includes('No errors logged.')) {
           errorLogContentEl.textContent = entry;
      }
  }
  window.onerror = function(message, source, lineno, colno, error) {
      logError(`Global: ${message} (Line ${lineno})`, 'WINDOW_ERROR');
      return true;
  };
  
  // --- Audio Functions (remain the same) ---
  const synth = window.speechSynthesis;
  function speak(s) {
    if (!synth) return;
    try {
        const ut = new SpeechSynthesisUtterance(s);
        ut.rate = 1.05; ut.pitch = 1;
        synth.speak(ut);
    } catch(e) { logError(e.message, 'Speech'); }
  }
  
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  function successBeep() { 
    try {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const o = audioCtx.createOscillator();
        o.type = 'triangle'; o.frequency.value = 1000;
        o.connect(audioCtx.destination);
        o.start(); o.stop(audioCtx.currentTime + 0.1);
    } catch(e) { logError(e.message, 'Audio'); }
  }
  function failBeep() { 
    try {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const o = audioCtx.createOscillator();
        o.type = 'square'; o.frequency.value = 300;
        o.connect(audioCtx.destination);
        o.start(); o.stop(audioCtx.currentTime + 0.2);
    } catch(e) { logError(e.message, 'Audio'); }
  }
  function readyBeep() { 
    try {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'sawtooth'; o.frequency.value = 600; 
        g.gain.value = 0.5; o.connect(g); g.connect(audioCtx.destination);
        o.frequency.exponentialRampToValueAtTime(800, audioCtx.currentTime + 0.1);
        o.start(); g.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.2);
        o.stop(audioCtx.currentTime + 0.2);
    } catch(e) { logError(e.message, 'Audio'); }
  }
  function punchBeep() { 
    try {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'sine'; o.frequency.value = 440; 
        g.gain.value = 0.3; o.connect(g); g.connect(audioCtx.destination);
        g.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.08); 
        o.start(); 
        o.stop(audioCtx.currentTime + 0.08);
    } catch(e) { logError(e.message, 'Audio'); }
  }

  let lastFeedbackAt = 0;
  function giveFeedback(text, speakIt=false, style='yellow') {
    const t = now();
    if (t - lastFeedbackAt < 1000 && style !== 'fail' && style !== 'wait' && currentMode === MODES.IDLE) return;
    lastFeedbackAt = t;
    feedbackEl.textContent = text;
    feedbackEl.style.opacity = 1;
    
    if(style === 'success') feedbackEl.style.color = '#00ff7f';
    else if(style === 'fail') feedbackEl.style.color = '#ff6b6b';
    else if(style === 'wait') feedbackEl.style.color = '#a0a0a0'; 
    else feedbackEl.style.color = '#ffeb3b';

    setTimeout(()=> feedbackEl.style.opacity = 0, 2000);
    if (speakIt) speak(text);
  }

  // --- Mode Management ---
  function startMode(mode) {
    if (!running) {
        giveFeedback("Please start the camera first.", false, 'fail');
        return;
    }
    
    if (currentMode !== MODES.IDLE) stopMode();
    
    currentMode = MODES.PENDING; 
    pendingMode = mode; 
    modeStatusEl.textContent = `${mode} (PENDING)`;
    pendingStatusEl.textContent = `Mode **${mode}** selected. Get in frame until confidence is good!`;

    // Button state management
    startDefenseBtn.disabled = (mode === MODES.SPARRING);
    startSparringBtn.disabled = (mode === MODES.DEFENSE_DRILL);
    sparringSelector.disabled = (mode === MODES.DEFENSE_DRILL);
    
    if (mode === MODES.DEFENSE_DRILL) {
        startDefenseBtn.textContent = 'Stop Drill';
    } else if (mode === MODES.SPARRING) {
        currentSparringDifficulty = sparringSelector.value;
        startSparringBtn.textContent = `Stop Sparring (${currentSparringDifficulty.toUpperCase()})`;
    }
    
    if (confidenceOK) {
        startModeExecution();
    } else {
        giveFeedback("Confidence low. Find your position!", false, 'wait');
    }
  }
  
  function startModeExecution() {
    if (currentMode !== MODES.PENDING || !pendingMode || !confidenceOK) return;
    
    const mode = pendingMode;
    currentMode = mode;
    pendingMode = null;
    attempts = 0;
    testResults = [];
    modeStatusEl.textContent = mode;
    pendingStatusEl.textContent = '';
    requiredDefense = null;
    
    if (mode === MODES.DEFENSE_DRILL) {
        speak("Defense Drill activated. React to the incoming attacks.");
    } else {
        speak(`Sparring Mode activated at ${currentSparringDifficulty} difficulty. Good luck!`);
    }
    
    issueCommand();
  }

  function stopMode() {
    if (currentMode === MODES.IDLE) return;
    
    let summaryText = `Session finished. Total attempts: ${attempts}. `;
    
    if (testResults.length > 0) {
        const hits = testResults.filter(r => r === 'HIT').length;
        const correctDefense = testResults.filter(r => r === 'SLIPPED' || r === 'BLOCKED').length;
        
        summaryText = `${currentMode.replace('_', ' ')} ENDED. Hits: ${hits}, Defenses: ${correctDefense}.`;
        
        if (hits > correctDefense) summaryText += " Focus more on defense timing!";
        else summaryText += " Solid defense and reaction time! ðŸ’ª";
    }
    
    giveFeedback(summaryText, true, 'success');
    
    currentMode = MODES.IDLE;
    pendingMode = null; 
    modeStatusEl.textContent = 'IDLE';
    pendingStatusEl.textContent = '';

    startDefenseBtn.textContent = '2. Defense & Counter Drill';
    startSparringBtn.textContent = '3. Start Sparring Mode';
    
    startDefenseBtn.disabled = !running;
    startSparringBtn.disabled = !running;
    sparringSelector.disabled = !running;
    
    drillCommandEl.style.opacity = 0;
    liveTestAttackEl.style.opacity = 0;
    liveTestAttackEl.style.transition = 'none';
    clearTimeout(attackTimeout);
  }

  // Defense/Sparring Command Logic
  function issueCommand() {
    if (currentMode === MODES.IDLE || currentMode === MODES.PENDING) return;
    
    if (attempts >= MAX_ATTEMPTS) {
        stopMode();
        return;
    }
    
    startAttackSimulation();
  }
  
  // New: Attack Simulation logic supporting straight and hook attacks
  function startAttackSimulation() {
      if (currentMode !== MODES.DEFENSE_DRILL && currentMode !== MODES.SPARRING) return;
      
      const difficulty = (currentMode === MODES.SPARRING) ? currentSparringDifficulty : 'moderate'; 
      const settings = DIFFICULTY_SETTINGS[difficulty];
      const attackPool = ATTACK_TYPES[settings.complexity];

      // Select a random attack from the pool
      const selectedAttack = attackPool[Math.floor(Math.random() * attackPool.length)];
      
      const attackType = selectedAttack.type;
      const attackSide = selectedAttack.side;
      requiredDefense = selectedAttack.defense;
      
      liveTestAttackEl.classList.remove('hit', 'slipped', 'blocked', 'attack-from-left', 'attack-from-right');
      
      drillCommandEl.innerHTML = `Attack ${attempts + 1}/${MAX_ATTEMPTS}: Incoming **${attackType}**! <br/> Required: **${requiredDefense.toUpperCase().replace('_', ' ')}**`;
      drillCommandEl.style.opacity = 1;
      drillCommandEl.style.background = '#ffeb3b';

      liveTestAttackEl.style.transition = 'none';
      liveTestAttackEl.style.width = '0';
      liveTestAttackEl.style.height = '0';
      liveTestAttackEl.style.opacity = 1;
      liveTestAttackEl.style.background = 'white';
      
      // Determine attack animation origin (Center for Straights, Side for Hooks)
      let animationDuration = settings.attackTime;
      if (attackType.includes('HOOK')) {
          liveTestAttackEl.classList.add(attackSide === 'left' ? 'attack-from-left' : 'attack-from-right');
          animationDuration *= 0.8; // Hooks are slightly faster to execute
      } else {
          liveTestAttackEl.style.transform = 'translate(-50%, -50%)';
      }

      setTimeout(() => {
          if (currentMode === MODES.IDLE) return;
          
          liveTestAttackEl.style.transition = `width ${animationDuration}ms linear, height ${animationDuration}ms linear, transform ${animationDuration}ms linear`;
          liveTestAttackEl.style.width = '100%';
          liveTestAttackEl.style.height = '100%';
          attackWindowActive = true;
          attackHit = true;

          attackTimeout = setTimeout(() => {
              attackWindowActive = false;
              if (attackHit) {
                  liveTestAttackEl.classList.add('hit');
                  checkTestComplete('HIT');
              } 
          }, animationDuration);
      }, 500); 
  }

  function checkTestComplete(result) {
      if (currentMode === MODES.IDLE) return;
      
      clearTimeout(attackTimeout);
      attackWindowActive = false;
      
      testResults.push(result);
      attempts++;
      
      let promptText = "";
      if (result === 'SLIPPED' || result === 'BLOCKED') {
          promptText = `âœ… DEFENSE SUCCESS! **${result}**`;
          successBeep();
          liveTestAttackEl.classList.add(result.toLowerCase());
      } else {
          promptText = 'âŒ **HIT!** Too slow or wrong defense.';
          failBeep();
      }
      
      drillCommandEl.innerHTML = promptText;
      drillCommandEl.style.background = (result === 'HIT') ? '#ff6b6b' : '#00ff7f';
      
      const settings = DIFFICULTY_SETTINGS[currentMode === MODES.SPARRING ? currentSparringDifficulty : 'moderate'];

      setTimeout(() => {
          liveTestAttackEl.style.opacity = 0;
          setTimeout(issueCommand, settings.waitTime);
      }, 1000);
  }

  // Called from analyzePose when an action is detected
  function handleDetectedAction(detectedAction, actionMeta) {
    try {
        if ((currentMode === MODES.DEFENSE_DRILL || currentMode === MODES.SPARRING) && attackWindowActive) {
            
            // Check if detected action matches required defense
            if ((detectedAction.includes('slip') || detectedAction.includes('block')) && detectedAction === requiredDefense) {
                attackHit = false; 
                checkTestComplete(detectedAction.toUpperCase().replace('_', ' '));
                return; 
            }
        }
        
        // Handle punch type counting
        if (detectedAction === 'jab') jabCount++;
        else if (detectedAction === 'cross') crossCount++;
        else if (detectedAction === 'hook') hookCount++;
        else if (detectedAction === 'uppercut') uppercutCount++; 
        // Blocks/Slips are not counted as punches

        // Play sound if a punch is detected and we are NOT in a defense mode
        const isPunch = detectedAction === 'jab' || detectedAction === 'cross' || detectedAction === 'hook' || detectedAction === 'uppercut';
        if (isPunch && currentMode === MODES.IDLE) {
             punchBeep(); 
        }

        // Update Punch UI
        punchesTotalEl.textContent = jabCount + crossCount + hookCount + uppercutCount;
        jabsCountEl.textContent = jabCount;
        crossesCountEl.textContent = crossCount;
        hooksCountEl.textContent = hookCount;
        uppercutsCountEl.textContent = uppercutCount;

    } catch (e) {
        logError(e.message, 'HandleAction');
    }
  }

  // --- Core Pose Analysis ---
  function analyzePose(kpMap) {
    try {
        const lw = kpMap['left_wrist'];
        const rw = kpMap['right_wrist'];
        const ls = kpMap['left_shoulder'];
        const rs = kpMap['right_shoulder'];
        const lelb = kpMap['left_elbow']; 
        const relb = kpMap['right_elbow']; 
        const nose = kpMap['nose'];
        const lHip = kpMap['left_hip'];
        const rHip = kpMap['right_hip'];
        const lEye = kpMap['left_eye'];
        const rEye = kpMap['right_eye'];

        if (!lw || !rw || !ls || !rs || !nose || !lelb || !relb || !lHip || !rHip || !lEye || !rEye) {
            // Reset punch debug if not enough keypoints
            punchStatusEl.textContent = 'Keypoints Missing';
            extRatioEl.textContent = '0.0'; armAngleEl.textContent = '0Â°'; centerCheckEl.textContent = 'No';
            return {}; 
        }
        
        // VISIBILITY CHECK - Must have hips visible
        if (lHip.score < MIN_HIP_CONFIDENCE || rHip.score < MIN_HIP_CONFIDENCE) {
            if (running) { 
                giveFeedback("âŒ Move back! Need to see your full torso (hip confidence too low).", false, 'fail');
            }
            punchStatusEl.textContent = 'Hips Not Visible';
            return {}; // Skip all detection and analysis
        }
        
        const timestamp = now();
        const rotationScore = calculateRotation(ls, rs, lHip, rHip);
        const techniqueScore = rotationScore;
        let detectedAction = null;
        let actionMeta = { techniqueScore: techniqueScore };
        
        // 1. Calculate Centerline and Stance
        const hipMidX = (lHip.x + rHip.x) / 2;
        const centerLineX = (nose.x + hipMidX) / 2; 
        
        // Determine Lead Hand (Pose is flipped: LHip further right (higher X) means orthodox/left lead)
        const isOrthodox = lHip.x > rHip.x;
        const leadHandSide = isOrthodox ? 'left' : 'right';
        
        // 2. Slip Check 
        if (timestamp - lastLeftAt > punchCooldown) { // Use cooldown for detection delay
            const slipType = checkSlip(nose, lHip, rHip, prevNose, prevLHip, prevRHip);
            if (slipType) { 
                detectedAction = slipType;
            }
        }
        
        // 3. Block Check (New Feature)
        if (!detectedAction) {
            const blockType = checkBlock(lw, rw, lEye, rEye, ls, rs, nose);
            if (blockType) {
                 detectedAction = blockType;
            }
        }

        // 4. Punch Check (Geometry & Centerline)
        if (!detectedAction) {
            let leftPunchMeta = {status: 'Inactive'}, rightPunchMeta = {status: 'Inactive'};

            // Left Arm Check
            if (timestamp - lastLeftAt > punchCooldown) {
                const result = checkPunchGeometry(lw, lelb, ls, centerLineX, 'left', leadHandSide, prevLeft);
                if (result.type) {
                    detectedAction = result.type;
                    lastLeftAt = timestamp;
                    leftPunchMeta = result.meta;
                } else {
                    leftPunchMeta = result.meta;
                }
            }
            
            // Right Arm Check
            if (!detectedAction && timestamp - lastRightAt > punchCooldown) {
                const result = checkPunchGeometry(rw, relb, rs, centerLineX, 'right', leadHandSide, prevRight);
                if (result.type) {
                    detectedAction = result.type;
                    lastRightAt = timestamp;
                    rightPunchMeta = result.meta;
                } else {
                    rightPunchMeta = result.meta;
                }
            }

            // Update debug info with the most recently checked arm's metrics
            const debugMeta = detectedAction ? (detectedAction.includes('left') ? leftPunchMeta : rightPunchMeta) : (lastLeftAt > lastRightAt ? leftPunchMeta : rightPunchMeta);
            if(debugMeta.status !== 'Inactive') {
                punchStatusEl.textContent = detectedAction ? detectedAction.toUpperCase() : debugMeta.status;
                extRatioEl.textContent = debugMeta.extRatio.toFixed(2);
                armAngleEl.textContent = debugMeta.armAngle.toFixed(0) + 'Â°';
                centerCheckEl.textContent = debugMeta.centerCheck ? 'YES' : 'No';
            } else {
                 punchStatusEl.textContent = 'Waiting for Extension';
                 extRatioEl.textContent = '0.0'; armAngleEl.textContent = '0Â°'; centerCheckEl.textContent = 'No';
            }
        } else {
             punchStatusEl.textContent = detectedAction.toUpperCase();
             extRatioEl.textContent = 'N/A'; armAngleEl.textContent = 'N/A'; centerCheckEl.textContent = 'N/A';
        }
        
        if (detectedAction) {
            handleDetectedAction(detectedAction, actionMeta);
        }

        drawOverlay(kpMap, {rotationScore, centerLineX}); 

        // Store new previous points 
        if(lw) prevLeft = {x: lw.x, y: lw.y};
        if(rw) prevRight = {x: rw.x, y: rw.y};
        if(nose) prevNose = {x: nose.x, y: nose.y};
        if(lHip) prevLHip = {x: lHip.x, y: lHip.y};
        if(rHip) prevRHip = {x: rHip.x, y: rHip.y};
        
        return {techniqueScore};

    } catch (e) {
        logError(e.message, 'AnalyzePose');
        return {};
    }
  }

  // --- Block Detection Logic (New Feature) ---
  function checkBlock(lw, rw, lEye, rEye, ls, rs, nose) {
      const NOSE_OFFSET = dist(lEye, rEye) * 0.5; // Half the distance between eyes as an offset for the face
      
      // Right Block (Right Hand near Right Side of Head)
      if (rw.x > nose.x + NOSE_OFFSET && Math.abs(rw.y - nose.y) < dist(rs, nose) * 0.5) {
          // Check if hand is near face and elbow is bent
          const rightArmAngle = getAngle(rs, rw, {x: rw.x, y: rw.y + 0.1}); // Using an arbitrary point to simulate a vertical line
          if (rightArmAngle > 100) { // Check for bent arm
              return 'block_right';
          }
      }

      // Left Block (Left Hand near Left Side of Head)
      if (lw.x < nose.x - NOSE_OFFSET && Math.abs(lw.y - nose.y) < dist(ls, nose) * 0.5) {
          const leftArmAngle = getAngle(ls, lw, {x: lw.x, y: lw.y + 0.1});
           if (leftArmAngle > 100) {
              return 'block_left';
          }
      }
      
      return null;
  }

  // --- GEOMETRY-BASED PUNCH CLASSIFICATION (Updated with debug output) ---
  function checkPunchGeometry(wrist, elbow, shoulder, centerLineX, side, leadHandSide, prevWrist) {
      const isLeadHand = side === leadHandSide;
      const isRearHand = !isLeadHand;
      
      const distToShoulder = dist(wrist, shoulder);
      const maxArmLength = dist(shoulder, {x: wrist.x, y: shoulder.y}); 
      const extensionRatio = distToShoulder / maxArmLength;
      
      const armAngleDeg = getAngle(shoulder, elbow, wrist); 
      
      let meta = {
          extRatio: extensionRatio,
          armAngle: armAngleDeg,
          centerCheck: false,
          status: 'Extending...'
      };

      // 1. Initial Extension/Commitment Check
      if (extensionRatio < minExtensionRatio) {
          meta.status = 'Not Extended';
          return {type: null, meta}; 
      }
      
      // 2. Centerline Check (Jab/Cross Target)
      const crossedCenter = (side === 'left' && wrist.x < centerLineX + CENTER_LINE_X_BUFFER) || 
                            (side === 'right' && wrist.x > centerLineX - CENTER_LINE_X_BUFFER); 
      meta.centerCheck = crossedCenter;
                            
      // 3. Classification
      
      // Check for Hook (Bent arm, lateral extension)
      if (armAngleDeg > HOOK_PUNCH_MIN_BEND_DEG && armAngleDeg < HOOK_PUNCH_MAX_BEND_DEG) {
          const lateralDistance = Math.abs(wrist.y - shoulder.y);
          const totalDistance = distToShoulder;
          if (lateralDistance / totalDistance > 0.3) { 
              meta.status = 'Detected: Hook';
              return {type: 'hook', meta};
          }
      }
      
      // Check for Uppercut (Bent arm, upward trajectory, wrist below shoulder)
      if (armAngleDeg > HOOK_PUNCH_MIN_BEND_DEG) { 
          if (wrist.y > shoulder.y) { // Wrist starts below the shoulder (higher Y)
              if (prevWrist) {
                  const yVelocity = wrist.y - prevWrist.y; 
                  if (yVelocity < -UPPERCUT_MIN_Y_VELOCITY) { // Moving UP (Y value decreasing)
                      meta.status = 'Detected: Uppercut';
                      return {type: 'uppercut', meta};
                  }
              }
          }
      }
      
      // Check for Jab/Cross (Straight arm, crossed center line)
      if (armAngleDeg < STRAIGHT_PUNCH_MAX_BEND_DEG) {
          if (crossedCenter) {
              if (isLeadHand) {
                  meta.status = 'Detected: Jab';
                  return {type: 'jab', meta};
              }
              if (isRearHand) {
                  meta.status = 'Detected: Cross';
                  return {type: 'cross', meta};
              }
          } else {
              meta.status = 'Straight, but didn\'t cross center';
          }
      } else {
           meta.status = 'Extended, but arm too bent for straight';
      }

      return {type: null, meta};
  }
  
  // --- Utility Functions (remain the same) ---
  function dist(a,b) { return Math.hypot(a.x-b.x, a.y-b.y); }
  function now() { return performance.now(); }
  
  function getAngle(p1, p2, p3) {
      if (!p1 || !p2 || !p3) return 180;
      const radians = Math.atan2(p3.y - p2.y, p3.x - p2.x) - Math.atan2(p1.y - p2.y, p1.x - p2.x);
      let angle = Math.abs(radians * 180.0 / Math.PI);
      if (angle > 180.0) {
          angle = 360.0 - angle;
      }
      return angle;
  }
  
  function calculateRotation(ls, rs, lHip, rHip) { 
    if (!ls || !rs || !lHip || !rHip) return 0;
    const shoulderAngle = Math.atan2(rs.y - ls.y, rs.x - ls.x);
    const hipAngle = Math.atan2(rHip.y - lHip.y, rHip.x - lHip.x);
    let rotation = Math.abs(shoulderAngle - hipAngle);
    if (rotation > Math.PI) rotation = 2 * Math.PI - rotation;
    let rotNorm = Math.min(rotation, Math.PI / 2) / (Math.PI / 2);
    const ROTATION_THRESHOLD_RAD = 0.30;
    return (rotation > ROTATION_THRESHOLD_RAD) ? rotNorm : 0;
  }
  
  function checkSlip(nose, lHip, rHip, prevNose, prevLHip, prevRHip) { 
      if (!nose || !lHip || !rHip || !prevNose || !prevLHip || !prevRHip) return null;
      
      const hipMidX = (lHip.x + rHip.x) / 2;
      const prevHipMidX = (prevLHip.x + prevRHip.x) / 2;
      
      const relativeNoseMoveX = (nose.x - hipMidX) - (prevNose.x - prevHipMidX);
      const bodyWidth = dist(lHip, rHip);
      const normalizedMoveX = relativeNoseMoveX / bodyWidth;
      const SLIP_THRESHOLD_X = 0.01;
      
      if (normalizedMoveX > SLIP_THRESHOLD_X) return 'slip_right'; 
      else if (normalizedMoveX < -SLIP_THRESHOLD_X) return 'slip_left'; 
      return null;
  }
  
  function drawOverlay(kpMap, meta) { 
    try {
        const w = overlayCanvas.width, h = overlayCanvas.height;
        overlayCtx.clearRect(0,0,w,h);
        const VISUAL_SCORE_THRESHOLD = 0.05; 
        const keypointConnectionsMap = [
          ['left_shoulder', 'right_shoulder'], ['left_shoulder', 'left_elbow'],
          ['right_shoulder', 'right_elbow'], ['left_elbow', 'left_wrist'],
          ['right_elbow', 'right_wrist'], ['left_shoulder', 'left_hip'],
          ['right_shoulder', 'right_hip'], ['left_hip', 'right_hip'],
          ['left_eye', 'right_eye'], ['left_eye', 'nose'], ['right_eye', 'nose'], // Face for block check
        ];
        overlayCtx.save();
        overlayCtx.strokeStyle = 'rgba(0,255,255,0.7)';
        overlayCtx.lineWidth = 2;
        for (const [p1Name, p2Name] of keypointConnectionsMap) {
          const p1 = kpMap[p1Name];
          const p2 = kpMap[p2Name];
          if (p1 && p2 && p1.score > VISUAL_SCORE_THRESHOLD && p2.score > VISUAL_SCORE_THRESHOLD) {
            overlayCtx.beginPath();
            overlayCtx.moveTo(p1.x * w, p1.y * h);
            overlayCtx.lineTo(p2.x * w, p2.y * h);
            overlayCtx.stroke();
          }
        }
        overlayCtx.fillStyle = 'rgba(0,255,255,0.8)';
        for (const k of Object.values(kpMap)) {
          if (k && k.score > VISUAL_SCORE_THRESHOLD) {
            overlayCtx.beginPath();
            overlayCtx.arc(k.x * w, k.y * h, 6, 0, Math.PI*2);
            overlayCtx.fill();
          }
        }
        // Draw Centerline
        if (meta.centerLineX) {
            overlayCtx.strokeStyle = '#ff00ff'; 
            overlayCtx.lineWidth = 1;
            overlayCtx.beginPath();
            overlayCtx.moveTo(meta.centerLineX * w, 0);
            overlayCtx.lineTo(meta.centerLineX * w, h);
            overlayCtx.stroke();
            overlayCtx.font = '10px Arial';
            overlayCtx.fillStyle = '#ff00ff';
            overlayCtx.fillText('Centerline', meta.centerLineX * w + 5, 20);
        }
        // Draw Rotation Feedback
        if (meta.rotationScore > 0.5) { 
          overlayCtx.strokeStyle = `rgba(255,255,0, ${meta.rotationScore})`;
          overlayCtx.lineWidth = 5;
          overlayCtx.strokeRect(10,10,w-20,h-20);
        }
        overlayCtx.restore();
    } catch (e) {
        logError(e.message, 'DrawOverlay');
    }
  }

  // --- Initialization and Run Loop ---
  
  async function loadDetector() { 
    statusEl.textContent = 'loading model...';
    try {
        const model = poseDetection.SupportedModels.BlazePose;
        const detectorConfig = {
          runtime: 'mediapipe', modelType: 'lite', enableSmoothing: true,
          solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/pose',
        };
        detector = await poseDetection.createDetector(model, detectorConfig);
        statusEl.textContent = 'model loaded';
    } catch (e) {
        logError(`Model Load Failed: ${e.message}`, 'Init');
        statusEl.textContent = `LOAD FAILED: ${e.message || 'Unknown error'}`;
    }
  }

  async function startCamera() { 
    const constraints = { 
      audio: false, 
      video: { facingMode: "user", width: { ideal: 320 }, height: { ideal: 240 } } 
    };
    try {
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        return new Promise((resolve) => {
            video.onloadedmetadata = () => {
                video.play();
                video.width = video.videoWidth;
                video.height = video.videoHeight;
                overlayCanvas.width = video.videoWidth;
                overlayCanvas.height = video.videoHeight;
                hiddenCanvas.width = video.videoWidth;
                hiddenCanvas.height = video.videoHeight;
                video.setAttribute("playsinline", "true");
                video.style.transform = "scaleX(-1)"; 
                resolve();
            };
        });
    } catch (e) {
        logError(`Camera Start Failed: ${e.message}`, 'Camera');
        throw e;
    }
  }

  async function runFrame() {
    if (!running) return;
    if (!detector) { statusEl.textContent = 'Detector not initialized.'; return; }
    
    const vw = video.videoWidth; const vh = video.videoHeight;
    const start = now();
    let maxScore = 0.0;
    
    try {
      hiddenCtx.save();
      hiddenCtx.scale(-1, 1);
      hiddenCtx.drawImage(video, -vw, 0, vw, vh);
      hiddenCtx.restore();
      const poses = await detector.estimatePoses(hiddenCanvas, { flipHorizontal: false });
      const end = now();
      const numericalLatency = end - start;
      latencyEl.textContent = `${numericalLatency.toFixed(0)}ms`;

      statusEl.textContent = `running (FPS: ${(1000 / numericalLatency).toFixed(1)})`;

      if (poses && poses.length > 0) {
        const primaryPose = poses[0];
        
        const pts = primaryPose.keypoints.reduce((map, k) => { map[k.name] = k; return map; }, {});
        let calculatedScore = 0.0;

        // 1. Attempt to use the official score
        if (typeof primaryPose.score === 'number' && primaryPose.score > 0.1) {
            calculatedScore = primaryPose.score;
        } else {
            // 2. Fallback: Calculate synthetic score from critical keypoints
            const criticalKeys = ['nose', 'left_shoulder', 'right_shoulder', 'left_hip', 'right_hip'];
            let scoreSum = 0;
            let scoreCount = 0;
            
            for (const key of criticalKeys) {
                if (pts[key] && typeof pts[key].score === 'number') {
                    scoreSum += pts[key].score;
                    scoreCount++;
                }
            }
            if (scoreCount > 0) {
                calculatedScore = scoreSum / scoreCount;
            }
        }
        
        maxScore = calculatedScore;
            
        // CHECK CONFIDENCE
        if (maxScore >= MIN_CONFIDENCE_THRESHOLD && !confidenceOK) {
            confidenceOK = true;
            if (currentMode === MODES.IDLE) { 
                speak("Confidence is good. Select your mode!");
                readyBeep(); 
            }
            if (currentMode === MODES.PENDING) { 
                readyBeep();
                startModeExecution(); 
            }
        } else if (maxScore < MIN_CONFIDENCE_THRESHOLD && confidenceOK) {
            confidenceOK = false;
            if (currentMode !== MODES.PENDING && currentMode !== MODES.IDLE) {
                stopMode(); 
                giveFeedback("Confidence lost. Mode stopped.", true, 'fail');
            }
        }
        
        if (vw > 0 && vh > 0) {
            const kpMap = {};
            for (const k of Object.values(pts)) {
              if (typeof k.x === 'number' && typeof k.y === 'number') {
                kpMap[k.name] = { x: k.x / vw, y: k.y / vh, score: k.score };
              }
            }
            analyzePose(kpMap);
        }
      } else {
        overlayCtx.clearRect(0,0,overlayCanvas.width,overlayCanvas.height);
        if(confidenceOK) confidenceOK = false;
        punchStatusEl.textContent = 'No Pose Detected';
      }
      
      confidenceEl.textContent = maxScore.toFixed(2);
      
    } catch (err) {
      logError(err.message, 'RunFrame');
      statusEl.textContent = `CRASH: ${err.message || 'Unknown Error'}`;
      running = false; 
    }
    
    // Button state logic (simplified)
    const isDefenseActive = currentMode === MODES.DEFENSE_DRILL || currentMode === MODES.PENDING && pendingMode === MODES.DEFENSE_DRILL;
    const isSparringActive = currentMode === MODES.SPARRING || currentMode === MODES.PENDING && pendingMode === MODES.SPARRING;

    startDefenseBtn.disabled = !running || isSparringActive;
    startSparringBtn.disabled = !running || isDefenseActive;
    sparringSelector.disabled = !running || isDefenseActive;

    if (running) {
        raf = requestAnimationFrame(runFrame);
    }
  }

  // --- Initial Setup and Event Handlers ---
  
  startBtn.onclick = async () => { 
    startBtn.disabled = true; stopBtn.disabled = false; resetBtn.disabled = false;
    statusEl.textContent = 'starting camera...';
    try { await startCamera(); } catch (e) {
      giveFeedback('Camera error. Ensure permissions are granted.', false, 'fail');
      startBtn.disabled = false; stopBtn.disabled = true; return;
    }
    if (!detector) await loadDetector();
    if (statusEl.textContent.includes('FAILED')) { startBtn.disabled = false; stopBtn.disabled = true; return; }
    running = true; confidenceOK = false; 
    giveFeedback("Adjust your distance until confidence is good.", false, 'wait');
    video.play(); runFrame();
    if (audioCtx.state === 'suspended') audioCtx.resume();
  };

  stopBtn.onclick = () => { 
    running = false; stopMode(); confidenceOK = false;
    startBtn.disabled = false; stopBtn.disabled = true;
    
    startDefenseBtn.disabled = true;
    startSparringBtn.disabled = true;
    sparringSelector.disabled = true;
    
    statusEl.textContent = 'stopped';
    if (raf) cancelAnimationFrame(raf);
    if (stream) { const tracks = stream.getTracks(); tracks.forEach(t => t.stop()); stream = null; }
  };

  resetBtn.onclick = () => { 
    // Reset all punch counters
    jabCount = 0; crossCount = 0; hookCount = 0; uppercutCount = 0;
    punchesTotalEl.textContent = 0;
    jabsCountEl.textContent = 0; crossesCountEl.textContent = 0; hooksCountEl.textContent = 0;
    uppercutsCountEl.textContent = 0;
    
    prevLeft = prevRight = prevNose = prevLHip = prevRHip = null;
    feedbackEl.textContent = '';
    
    if(currentMode !== MODES.IDLE) {
        const targetMode = pendingMode || currentMode;
        stopMode(); 
        setTimeout(() => startMode(targetMode), 500);
    } else { giveFeedback("Counts reset.", false); }
  };
  
  // Handlers for the two main modes
  startDefenseBtn.onclick = () => {
      if (currentMode === MODES.DEFENSE_DRILL || currentMode === MODES.PENDING && pendingMode === MODES.DEFENSE_DRILL) { 
          stopMode(); 
      } else { 
          startMode(MODES.DEFENSE_DRILL); 
      }
  };
  
  startSparringBtn.onclick = () => {
      if (currentMode === MODES.SPARRING || currentMode === MODES.PENDING && pendingMode === MODES.SPARRING) { 
          stopMode(); 
      } else { 
          startMode(MODES.SPARRING); 
      }
  };
  
  statusEl.textContent = 'ready';
})();
</script>
</body>
</html>
