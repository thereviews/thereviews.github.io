<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>AI Boxing Coach — Simpler, Focused Modes</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose"></script> 
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
  
  <style>
    body { 
      margin:0; padding:0; 
      font-family:system-ui, Arial;
      background:#0a0a0a; color:#eee; 
      display:flex; flex-direction:column; 
      align-items:center; 
      overflow:hidden;
    }
    #wrap {
      position:relative;
      width:100vw; 
      max-width:450px;   
      height:75vh;       
      background:#000;
      border-radius:10px;
      overflow:hidden;
    }
    video, canvas { 
      position:absolute;
      top:0; left:0;
      width:100%; height:100%;
      object-fit:cover;
    }
    #hiddenCanvas {
        display: none; 
    }
    #hud {
      position:absolute;
      top:0; left:0;
      width:100%;
      display:flex;
      flex-wrap:wrap;
      justify-content:space-between;
      background:rgba(0,0,0,0.35);
      padding:6px 10px;
      font-size:12px;
      box-sizing:border-box;
      z-index: 5;
    }
    .stat { 
      padding:2px 4px;
      color:#0ff; font-weight:600;
    }
    
    /* COMMAND PANEL */
    #drillCommand {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 15px 25px;
        background: rgba(255, 255, 255, 0.95);
        color: #000;
        font-size: 24px;
        font-weight: bold;
        border-radius: 12px;
        z-index: 10;
        min-width: 200px;
        text-align: center;
        opacity: 0;
        transition: opacity 0.3s, background 0.3s;
        box-shadow: 0 4px 15px rgba(0,0,0,0.4);
    }
    
    /* VISUAL SPARRING CUE */
    #cue-container {
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9;
        pointer-events: none; /* Allows clicks to pass through */
    }
    #visual-cue {
        width: 10px; 
        height: 10px;
        background: white;
        border-radius: 50%;
        opacity: 0;
        transform: scale(0);
        transition: transform linear, background-color 0s;
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }
    #visual-cue.active {
        opacity: 1;
        /* The transition duration (e.g., 800ms) will be set in JS */
        /* Targets 450px wide container to ensure it fills the whole screen */
        transform: scale(45); 
    }


    #debug {
      width: 100%;
      padding-top: 5px;
      margin-top: 5px;
      border-top: 1px solid rgba(255, 255, 255, 0.2);
      font-size: 10px;
    }
    #debug span { margin-right: 10px; }
    #status.error { color: #ff6b6b; font-weight: bold; }

    #controls {
      margin-top:10px;
      display:flex; gap:8px;
      flex-wrap:wrap;
      justify-content:center;
    }
    button, select { 
      padding:10px 15px; border-radius:10px; 
      border:none; 
      font-weight:700;
      cursor: pointer;
      box-shadow: 0 4px #00000033;
      transition: all 0.1s ease-out;
    }
    button:active { transform: translateY(2px); box-shadow: 0 2px #00000033; }
    
    #startBtn { background: #007bff; color:#fff; }
    #stopBtn, #resetBtn { background: #444; color:#fff; }
    #startDrillBtn { background: #00b0ff; color:#000; }
    #startTestBtn { background: #ff7043; color:#000; }
    #drillSelector { background: #fff; color:#000; font-weight: 600; }

    button:disabled, select:disabled {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
    }
    
    #feedback {
      margin-top:10px;
      font-size: 18px;
      font-weight: bold;
      text-align: center;
      min-height: 24px;
      opacity: 0;
      transition: opacity 0.2s;
    }
  </style>
</head>
<body>
  <h3 style="margin:10px 0 5px 0">AI Boxing Coach</h3>

  <div id="wrap">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
    <canvas id="hiddenCanvas"></canvas>
    
    <div id="cue-container"><div id="visual-cue"></div></div>

    <div id="hud">
      <div class="row">
        <div><span class="stat">Total Punches</span> <span id="punches">0</span></div>
      </div>
      
      <div id="debug">
          <small>Status: <span id="status">idle</span></small>
          <br/>
          <span>Latency: <b id="latency">0ms</b></span>
          <span>Max Score: <b id="confidence">0.0</b></span>
          <span>Mode: <b id="modeStatus">IDLE</b></span>
      </div>
    </div>
    
    <div id="drillCommand"></div>
    
  </div>

  <div id="controls">
    <button id="startBtn">1. Start Camera</button>
    <button id="stopBtn" disabled>Stop</button>
    <button id="resetBtn">Reset Counts</button>
    
    <hr style="width:100%; border:0; margin:5px 0;">
    
    <select id="drillSelector" disabled>
        </select>
    <button id="startDrillBtn" disabled>2. Start Drill</button>
    <button id="startTestBtn" disabled>2. Start Live Test</button>
  </div>

  <div id="feedback"></div>

<script>
(async ()=> {
  // Elements
  const video = document.getElementById('video');
  const overlayCanvas = document.getElementById('overlay');
  const overlayCtx = overlayCanvas.getContext('2d');
  const hiddenCanvas = document.getElementById('hiddenCanvas');
  
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const resetBtn = document.getElementById('resetBtn');
  const startDrillBtn = document.getElementById('startDrillBtn');
  const startTestBtn = document.getElementById('startTestBtn');
  const drillSelector = document.getElementById('drillSelector');
  
  const statusEl = document.getElementById('status');
  const drillCommandEl = document.getElementById('drillCommand'); 
  const cue = document.getElementById('visual-cue');
  
  // HUD elements
  const latencyEl = document.getElementById('latency');
  const confidenceEl = document.getElementById('confidence');
  const modeStatusEl = document.getElementById('modeStatus');
  const punchesEl = document.getElementById('punches');

  // State
  let detector = null;
  let running = false;
  let raf = null;
  let stream = null;
  
  let totalPunches = 0;

  // Mode State
  const MODES = { IDLE: 'IDLE', DRILL: 'DRILL', LIVE_TEST: 'LIVE_TEST' };
  let currentMode = MODES.IDLE;
  let confidenceOK = false;
  const MIN_CONFIDENCE_THRESHOLD = 0.70; 

  // Combo/Test State
  let requiredSequence = [];
  let currentStepIndex = 0;
  let attempts = 0;
  const MAX_ATTEMPTS = 10;
  let drillScores = []; 
  let testHits = 0;
  let testMisses = 0;
  let cueTimer = null;
  const CUE_TIME_MS = 600; // Time the expanding cue takes to fill the screen

  // Previous keypoints for velocity/detection
  let prevLeft = null, prevRight = null, prevNose = null, prevLHip = null, prevRHip = null;

  // Punch detection thresholds (MAX SENSITIVITY)
  const punchCooldown = 300; 
  const speedThreshold = 0.03; 
  const minForwardX = 0.002; 
  const dominanceRatio = 1.0; 
  const ROTATION_THRESHOLD_RAD = 0.30; 
  const SLIP_THRESHOLD_X = 0.01; 
  const PUNCH_TYPES = ['jab', 'cross', 'hook', 'uppercut'];
  const DEFENSE_TYPES = ['slip_left', 'slip_right'];

  let lastLeftAt = 0, lastRightAt = 0;
  
  // Drill Command List (Focus on defense combinations)
  const COMMANDS = [
    { name: "PUNCH, SLIP LEFT", sequence: ["punch", "slip_left"] },
    { name: "PUNCH, SLIP RIGHT", sequence: ["punch", "slip_right"] },
    { name: "SLIP LEFT, PUNCH", sequence: ["slip_left", "punch"] },
    { name: "SLIP RIGHT, PUNCH", sequence: ["slip_right", "punch"] },
    { name: "PUNCH, PUNCH, SLIP LEFT", sequence: ["punch", "punch", "slip_left"] },
    { name: "PUNCH, PUNCH, SLIP RIGHT", sequence: ["punch", "punch", "slip_right"] },
  ];
  
  // Audio functions
  const synth = window.speechSynthesis;
  function speak(s) {
    if (!synth) return;
    const ut = new SpeechSynthesisUtterance(s);
    ut.rate = 1.05; ut.pitch = 1;
    synth.speak(ut);
  }
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  function punchBeep() {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
    o.type = 'sine'; o.frequency.value = 800;
    g.gain.value = 0.0001; o.connect(g); g.connect(audioCtx.destination);
    o.start();
    g.gain.exponentialRampToValueAtTime(0.3, audioCtx.currentTime + 0.01);
    g.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.1);
    o.stop(audioCtx.currentTime + 0.11);
  }
  function successBeep() {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
    o.type = 'square'; o.frequency.value = 1500;
    g.gain.value = 0.0001; o.connect(g); g.connect(audioCtx.destination);
    o.start();
    g.gain.exponentialRampToValueAtTime(0.3, audioCtx.currentTime + 0.01);
    g.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.2);
    o.stop(audioCtx.currentTime + 0.21);
  }
  function failBeep() {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
    o.type = 'square'; o.frequency.value = 300;
    g.gain.value = 0.0001; o.connect(g); g.connect(audioCtx.destination);
    o.start();
    g.gain.exponentialRampToValueAtTime(0.3, audioCtx.currentTime + 0.01);
    g.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.3);
    o.stop(audioCtx.currentTime + 0.31);
  }

  let lastFeedbackAt = 0;
  function giveFeedback(text, speakIt=false, style='yellow') {
    // ... (Feedback function unchanged for brevity)
    const feedbackEl = document.getElementById('feedback');
    const t = now();
    if (t - lastFeedbackAt < 1000 && currentMode === MODES.IDLE) return;
    lastFeedbackAt = t;
    feedbackEl.textContent = text;
    feedbackEl.style.opacity = 1;
    
    if(style === 'success') feedbackEl.style.color = '#00ff7f';
    else if(style === 'fail') feedbackEl.style.color = '#ff6b6b';
    else if(style === 'wait') feedbackEl.style.color = '#a0a0a0'; 
    else feedbackEl.style.color = '#ffeb3b';

    setTimeout(()=> feedbackEl.style.opacity = 0, 2000);
    if (speakIt) speak(text);
  }

  // --- Mode Management ---
  function populateDrillSelector() {
      drillSelector.innerHTML = '<option value="-1">--- Choose Combo ---</option>';
      COMMANDS.forEach((cmd, index) => {
          const option = document.createElement('option');
          option.value = index;
          option.textContent = cmd.name;
          drillSelector.appendChild(option);
      });
  }

  function startMode(mode) {
    if (!running || !confidenceOK) {
        giveFeedback("Confidence is low or camera is not running.", false, 'fail');
        return;
    }
    
    if (mode === MODES.DRILL && drillSelector.value === "-1") {
        giveFeedback("Select a drill combo first.", false, 'fail');
        return;
    }

    currentMode = mode;
    attempts = 0;
    drillScores = [];
    testHits = 0;
    testMisses = 0;
    modeStatusEl.textContent = mode;
    
    startDrillBtn.disabled = (mode === MODES.LIVE_TEST);
    startTestBtn.disabled = (mode === MODES.DRILL);
    drillSelector.disabled = (mode !== MODES.DRILL);

    if (mode === MODES.DRILL) {
        startDrillBtn.textContent = 'Stop Drill';
        giveFeedback("Drill Mode: Focus on technique and rotation.", false, 'success');
        const selectedIndex = parseInt(drillSelector.value);
        requiredSequence = COMMANDS[selectedIndex].sequence;
        issueDrillCommand();
    } else { // LIVE_TEST
        startTestBtn.textContent = 'Stop Live Test';
        giveFeedback("Live Test: React to the visual cue to slip!", false, 'success');
        issueLiveTestCommand();
    }
  }
  
  function stopMode() {
    if (currentMode === MODES.IDLE) return;
    
    if (cueTimer) clearTimeout(cueTimer);
    cue.classList.remove('active');
    cue.style.backgroundColor = 'white';

    let summaryText = `Session finished. Total attempts: ${attempts}. `;
    
    if (currentMode === MODES.DRILL && drillScores.length > 0) {
        const avgTechnique = drillScores.reduce((a, b) => a + b, 0) / drillScores.length;
        summaryText += `Average technique score: ${(avgTechnique * 100).toFixed(1)}%.`;
    } else if (currentMode === MODES.LIVE_TEST) {
        const missRate = attempts > 0 ? (testMisses / attempts) * 100 : 0;
        summaryText += `Miss Rate: ${missRate.toFixed(1)}% (${testMisses} hits).`;
        if (missRate > 50) summaryText += " Focus on anticipation and speed!";
        else summaryText += " Solid defense!";
    }
    
    giveFeedback(summaryText, false, 'success');
    
    currentMode = MODES.IDLE;
    modeStatusEl.textContent = 'IDLE';
    startDrillBtn.textContent = '2. Start Drill';
    startTestBtn.textContent = '2. Start Live Test';
    
    // Re-enable all primary controls if confidence is OK
    startDrillBtn.disabled = !confidenceOK;
    startTestBtn.disabled = !confidenceOK;
    drillSelector.disabled = !confidenceOK;
    drillCommandEl.style.opacity = 0;
    drillCommandEl.textContent = '';
  }

  // --- Drill Mode Logic ---
  function issueDrillCommand() {
    if (currentMode !== MODES.DRILL || attempts >= MAX_ATTEMPTS) {
        stopMode();
        return;
    }
    
    // Command is pre-selected by the dropdown
    const command = COMMANDS[parseInt(drillSelector.value)];
    requiredSequence = command.sequence;
    currentStepIndex = 0;
    
    drillCommandEl.textContent = `Attempt ${attempts + 1}/${MAX_ATTEMPTS}: ${command.name}`;
    drillCommandEl.style.opacity = 1;
    drillCommandEl.style.background = '#ffeb3b';
    
    setTimeout(() => {
        if (currentMode !== MODES.DRILL) return;
        drillCommandEl.textContent = `${command.name} - GO!`;
        drillCommandEl.style.background = '#00ff7f'; 
    }, 1000); 
  }
  
  // --- Live Test Mode Logic (Visual Sparring) ---
  function issueLiveTestCommand() {
    if (currentMode !== MODES.LIVE_TEST || attempts >= MAX_ATTEMPTS) {
        stopMode();
        return;
    }
    
    attempts++;
    drillCommandEl.textContent = `Round ${attempts}/${MAX_ATTEMPTS}: GET READY`;
    drillCommandEl.style.opacity = 1;
    drillCommandEl.style.background = '#ffeb3b';
    requiredSequence = DEFENSE_TYPES[Math.floor(Math.random() * DEFENSE_TYPES.length)]; // Randomly choose one slip
    currentStepIndex = 0; // Ready to detect the slip/sweep
    
    const waitTime = Math.random() * 2000 + 1000; // 1 to 3 seconds wait
    
    // 1. Wait, then start the visual cue
    setTimeout(() => {
        if (currentMode !== MODES.LIVE_TEST) return;
        
        // Start the visual cue animation
        cue.style.transitionDuration = `${CUE_TIME_MS}ms`;
        cue.style.backgroundColor = 'white';
        cue.classList.add('active');
        
        drillCommandEl.textContent = `SLIP NOW!`;
        drillCommandEl.style.background = '#00ff7f';
        
        // 2. Set timeout for end of punch (when cue reaches max size)
        cueTimer = setTimeout(() => {
            checkLiveTestResult(false); // If timeout fires, the user was HIT (failed to slip)
        }, CUE_TIME_MS + 50); // Small buffer
        
    }, waitTime); 
  }

  function checkLiveTestResult(slippedSuccessfully) {
    if (currentMode !== MODES.LIVE_TEST || cue.classList.contains('hit') || cue.classList.contains('slipped')) return; 

    clearTimeout(cueTimer);
    cue.classList.remove('active');
    
    if (slippedSuccessfully) {
        testHits++;
        cue.style.backgroundColor = 'green';
        cue.classList.add('slipped');
        drillCommandEl.textContent = 'SLIPPED! (Green)';
        successBeep();
        
    } else {
        testMisses++;
        cue.style.backgroundColor = 'red';
        cue.classList.add('hit');
        drillCommandEl.textContent = 'HIT! (Red)';
        failBeep();
    }
    
    // Clear cue state and move to next round
    setTimeout(() => {
        cue.classList.remove('slipped', 'hit');
        issueLiveTestCommand(); 
    }, 1500);
  }


  // --- Action Handler ---
  function handleDetectedAction(detectedAction, actionMeta) {
    if (currentMode === MODES.IDLE || drillCommandEl.style.background !== 'rgb(0, 255, 127)') return;

    let matched = false;
    let expectedActionType = requiredSequence[currentStepIndex];

    if (currentMode === MODES.DRILL) {
        // DRILL MODE: Check sequence against the selected combo
        if (expectedActionType === 'punch' && PUNCH_TYPES.includes(detectedAction)) {
            matched = true;
        } else if (expectedActionType === detectedAction) { 
            matched = true;
        } 
        
        if (matched) {
            currentStepIndex++;
            if (PUNCH_TYPES.includes(detectedAction)) { drillScores.push(actionMeta.techniqueScore); } // Store technique score
            
            if (currentStepIndex >= requiredSequence.length) {
                // Sequence complete!
                checkDrillComplete(true);
            } else {
                giveFeedback(detectedAction.toUpperCase().replace('_', ' ') + " received. Next!", false, 'wait');
            }
        } else if (PUNCH_TYPES.includes(detectedAction) || DEFENSE_TYPES.includes(detectedAction)) {
            // Wrong move in combo
            checkDrillComplete(false, { wrongMove: detectedAction }); 
        }

    } else if (currentMode === MODES.LIVE_TEST) {
        // LIVE TEST MODE: Only check for the required slip
        if (DEFENSE_TYPES.includes(detectedAction)) {
            checkLiveTestResult(true);
        }
    }
  }

  function checkDrillComplete(success) {
    attempts++;
    let feedbackText = "";
    
    if (success) {
        const avgTechnique = drillScores.length > 0 ? (drillScores.reduce((a, b) => a + b, 0) / drillScores.length) : 1;
        
        if (avgTechnique < 0.5) feedbackText = `Needs work! Technique ${(avgTechnique*100).toFixed(0)}%. Focus on **rotation**.`;
        else if (avgTechnique < 0.75) feedbackText = `Good! Technique ${(avgTechnique*100).toFixed(0)}%.`;
        else feedbackText = `Excellent Technique! ${(avgTechnique*100).toFixed(0)}%.`;
        
        drillCommandEl.textContent = '✅ SUCCESS';
        drillCommandEl.style.background = '#00ff7f';
        successBeep();
    } else { 
        feedbackText = "FAILED! Sequence broken or wrong move.";
        drillCommandEl.textContent = '❌ FAILED';
        drillCommandEl.style.background = '#ff6b6b';
        failBeep();
    }

    giveFeedback(feedbackText, false, success ? 'success' : 'fail');
    setTimeout(issueDrillCommand, 3000); 
  }


  // --- Core Processing Functions ---
  function dist(a,b) { return Math.hypot(a.x-b.x, a.y-b.y); }
  function now() { return performance.now(); }
  
  function calculateRotation(ls, rs, lHip, rHip) {
    // ... (Rotation calculation unchanged)
    if (!ls || !rs || !lHip || !rHip) return 0;
    const shoulderAngle = Math.atan2(rs.y - ls.y, rs.x - ls.x);
    const hipAngle = Math.atan2(rHip.y - lHip.y, rHip.x - lHip.x);
    let rotation = Math.abs(shoulderAngle - hipAngle);
    if (rotation > Math.PI) rotation = 2 * Math.PI - rotation;
    let rotNorm = Math.min(rotation, Math.PI / 2) / (Math.PI / 2);
    return (rotation > ROTATION_THRESHOLD_RAD) ? rotNorm : 0;
  }
  
  function checkSlip(nose, lHip, rHip, prevNose, prevLHip, prevRHip) {
      // ... (Slip check unchanged)
      if (!nose || !lHip || !rHip || !prevNose || !prevLHip || !prevRHip) return null;
      const hipMidX = (lHip.x + rHip.x) / 2;
      const prevHipMidX = (prevLHip.x + prevRHip.x) / 2;
      const relativeNoseMoveX = (nose.x - hipMidX) - (prevNose.x - prevHipMidX);
      const bodyWidth = dist(lHip, rHip);
      const normalizedMoveX = relativeNoseMoveX / bodyWidth;
      
      if (normalizedMoveX > SLIP_THRESHOLD_X) return 'slip_right'; 
      else if (normalizedMoveX < -SLIP_THRESHOLD_X) return 'slip_left'; 
      return null;
  }

  function analyzePose(kpMap) {
    // ... (Keypoint setup unchanged)
    const lw = kpMap['left_wrist']; const rw = kpMap['right_wrist'];
    const ls = kpMap['left_shoulder']; const rs = kpMap['right_shoulder'];
    const nose = kpMap['nose']; const lHip = kpMap['left_hip']; const rHip = kpMap['right_hip'];

    if (!lw || !rw || !ls || !rs || !nose) return {};
    
    let leftVel = {x:0,y:0}, rightVel={x:0,y:0};
    if (prevLeft) { leftVel = { x: lw.x - prevLeft.x, y: lw.y - prevLeft.y }; }
    if (prevRight) { rightVel = { x: rw.x - prevRight.x, y: rw.y - prevRight.y }; }

    const rotationScore = calculateRotation(ls, rs, lHip, rHip);
    const techniqueScore = rotationScore; 
    let detectedAction = null;
    const timestamp = now();
    let actionMeta = { techniqueScore: techniqueScore };
    
    // Defense Detection
    const slipType = checkSlip(nose, lHip, rHip, prevNose, prevLHip, prevRHip);
    if (slipType && (timestamp - lastLeftAt) > punchCooldown) { 
        detectedAction = slipType;
    }
    
    // Punch detection logic (Simplified: tracks only a single 'punch' type)
    if (!detectedAction) {
        // Left Punch Check
        if (prevLeft) {
            const delta = dist(lw, ls) - dist(prevLeft, ls);
            if (delta > speedThreshold && (timestamp - lastLeftAt) > punchCooldown) {
                if (leftVel.x > minForwardX && Math.abs(leftVel.x) >= Math.abs(leftVel.y) * dominanceRatio) { 
                    punchBeep();
                    detectedAction = 'punch'; 
                    totalPunches++; punchesEl.textContent = totalPunches; 
                    lastLeftAt = timestamp;
                }
            }
        }
        
        // Right Punch Check
        if (prevRight) {
            const deltaR = dist(rw, rs) - dist(prevRight, rs);
            if (deltaR > speedThreshold && (timestamp - lastRightAt) > punchCooldown) {
                if (rightVel.x < -minForwardX && Math.abs(rightVel.x) >= Math.abs(rightVel.y) * dominanceRatio) { 
                    punchBeep();
                    detectedAction = 'punch'; 
                    totalPunches++; punchesEl.textContent = totalPunches; 
                    lastRightAt = timestamp;
                }
            }
        }
    }
    
    // Drill/Test Mode Check
    if (currentMode !== MODES.IDLE && detectedAction) {
        handleDetectedAction(detectedAction, actionMeta);
    }

    drawOverlay(kpMap, {rotationScore});

    // Update previous keypoints
    if(lw) prevLeft = {x: lw.x, y: lw.y}; if(rw) prevRight = {x: rw.x, y: rw.y};
    if(nose) prevNose = {x: nose.x, y: nose.y}; if(lHip) prevLHip = {x: lHip.x, y: lHip.y};
    if(rHip) prevRHip = {x: rHip.x, y: rHip.y};
    
    return {techniqueScore};
  }

  // --- UI/Control Functions ---
  
  startBtn.onclick = async () => {
    // ... (Start camera logic mostly unchanged)
    startBtn.disabled = true; stopBtn.disabled = false; resetBtn.disabled = false;
    try {
      await startCamera();
    } catch (e) {
      giveFeedback('Camera error. Ensure permissions are granted: ' + (e.message || e), true, 'fail');
      startBtn.disabled = false; stopBtn.disabled = true; return;
    }
    if (!detector) await loadDetector();
    if (statusEl.classList.contains('error')) { 
        startBtn.disabled = false; stopBtn.disabled = true; return; 
    }
    running = true;
    confidenceOK = false; 
    // FIX: Set initial state of buttons to disabled until confidence is met.
    startDrillBtn.disabled = true; startTestBtn.disabled = true; drillSelector.disabled = true;
    giveFeedback("Adjust distance. Waiting for confidence check.", false, 'wait');
    populateDrillSelector();
    video.play();
    runFrame();
    if (audioCtx.state === 'suspended') audioCtx.resume();
  };

  stopBtn.onclick = () => {
    running = false;
    stopMode(); 
    confidenceOK = false;
    startBtn.disabled = false; stopBtn.disabled = true;
    if (raf) cancelAnimationFrame(raf);
    if (stream) {
      const tracks = stream.getTracks();
      tracks.forEach(t => t.stop());
      stream = null;
    }
  };

  resetBtn.onclick = () => {
    totalPunches = 0; punchesEl.textContent = 0;
    if(currentMode !== MODES.IDLE) {
        stopMode(); 
    }
  };
  
  startDrillBtn.onclick = () => {
      if (currentMode === MODES.DRILL) { stopMode(); } else { startMode(MODES.DRILL); }
  };
  
  startTestBtn.onclick = () => {
      if (currentMode === MODES.LIVE_TEST) { stopMode(); } else { startMode(MODES.LIVE_TEST); }
  };
  
  // RENDER LOOP (runFrame) has minor updates for mode control
  async function runFrame() {
    // ... (runFrame logic)
      if (poses && poses.length > 0) {
        const primaryPose = poses[0];
        
        if (typeof primaryPose.score === 'number') {
            // ... (MaxScore calculation)
            // Confidence Monitor Logic
            if (primaryPose.score >= MIN_CONFIDENCE_THRESHOLD && !confidenceOK) {
                confidenceOK = true;
                speak("Confidence is good. Select your mode!");
                // FIX: Enable buttons here once confidence is confirmed
                startDrillBtn.disabled = false; startTestBtn.disabled = false; drillSelector.disabled = false;
            } else if (primaryPose.score < MIN_CONFIDENCE_THRESHOLD && confidenceOK) {
                confidenceOK = false;
                speak("Move back slightly, confidence is low.");
                // Disable modes if confidence is lost
                if(currentMode !== MODES.IDLE) stopMode();
                startDrillBtn.disabled = true; startTestBtn.disabled = true; drillSelector.disabled = true;
            }
        }
        // ... (rest of runFrame logic unchanged)
      } else {
        // ... (No pose detected logic)
        if(confidenceOK) { confidenceOK = false; speak("No person detected. Stand in frame."); }
        if(currentMode !== MODES.IDLE) stopMode();
        startDrillBtn.disabled = true; startTestBtn.disabled = true; drillSelector.disabled = true;
      }
      
      confidenceEl.textContent = maxScore;
    // ...
    if (running) { raf = requestAnimationFrame(runFrame); }
  }


  // init ready
  statusEl.textContent = 'ready';
  populateDrillSelector();
})();
</script>
</body>
</html>
